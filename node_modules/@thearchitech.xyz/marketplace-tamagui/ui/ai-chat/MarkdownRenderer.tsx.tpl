'use client';

import React, { useState, useRef, useEffect } from 'react';
import { Copy, Check, ExternalLink, Code, ChevronDown, ChevronRight } from 'lucide-react-native';
import { useTranslation } from '@/lib/i18n';
import { toast } from '@/hooks/use-toast';

import {
  YStack,
  XStack,
  Button,
  Card,
  CardContent,
  Badge,
  Separator,
  ScrollView,
  Text,
  Theme,
  Square,
  Collapsible
} from 'tamagui';

interface MarkdownRendererProps {
  content: string;
  allowCopy?: boolean;
  allowCollapse?: boolean;
}

interface CodeBlockProps {
  language: string;
  code: string;
  allowCopy?: boolean;
}

interface TableProps {
  headers: string[];
  rows: string[][];
}

function CodeBlock({ language, code, allowCopy = true }: CodeBlockProps) {
  const { t } = useTranslation();
  const [copied, setCopied] = useState(false);
  const codeRef = useRef<HTMLPreElement>(null);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setCopied(true);
      toast({
        title: t('common.copied'),
        description: t('chat.codeCopied'),
      });
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      console.error('Failed to copy code:', error);
      toast({
        title: t('common.error'),
        description: t('chat.copyFailed'),
        variant: 'destructive',
      });
    }
  };

  return (
    <YStack position="relative">
      <Card
        overflow="hidden"
        elevate
        bordered
      >
        <XStack 
          alignItems="center" 
          justifyContent="space-between" 
          paddingHorizontal="$4" 
          paddingVertical="$2"
          backgroundColor="$backgroundHover"
          borderBottomWidth={1}
          borderBottomColor="$borderColor"
        >
          <XStack alignItems="center" gap="$2">
            <Code size={16} />
            <Text fontWeight="$6" fontSize="$2">{language}</Text>
          </XStack>
          {allowCopy && (
            <Button
              size="$2"
              circular
              chromeless
              onPress={handleCopy}
              opacity={0}
              hoverStyle={{ opacity: 1 }}
              animation="quick"
            >
              <Square>
                {copied ? (
                  <Check size={12} color="$green10" />
                ) : (
                  <Copy size={12} />
                )}
              </Square>
            </Button>
          )}
        </XStack>
        <CardContent padding={0}>
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={true}
            maxHeight={384}
          >
            <ScrollView 
              showsVerticalScrollIndicator={true}
            >
              <YStack
                ref={codeRef}
                padding="$4"
                backgroundColor="$background"
              >
                <Text 
                  fontFamily="$mono" 
                  fontSize="$2" 
                  whiteSpace="pre"
                  userSelect="text"
                >
                  {code}
                </Text>
              </YStack>
            </ScrollView>
          </ScrollView>
        </CardContent>
      </Card>
    </YStack>
  );
}

function Table({ headers, rows }: TableProps) {
  return (
    <ScrollView horizontal showsHorizontalScrollIndicator={true}>
      <YStack 
        borderWidth={1} 
        borderColor="$borderColor" 
        borderRadius="$2"
        overflow="hidden"
      >
        <XStack backgroundColor="$backgroundHover">
          {headers.map((header, index) => (
            <Text
              key={index}
              borderWidth={1}
              borderColor="$borderColor"
              paddingHorizontal="$4"
              paddingVertical="$2"
              fontWeight="$6"
              minWidth={100}
            >
              {header}
            </Text>
          ))}
        </XStack>
        <YStack>
          {rows.map((row, rowIndex) => (
            <XStack 
              key={rowIndex} 
              hoverStyle={{ backgroundColor: "$backgroundHover" }}
            >
              {row.map((cell, cellIndex) => (
                <Text
                  key={cellIndex}
                  borderWidth={1}
                  borderColor="$borderColor"
                  paddingHorizontal="$4"
                  paddingVertical="$2"
                  minWidth={100}
                >
                  {cell}
                </Text>
              ))}
            </XStack>
          ))}
        </YStack>
      </YStack>
    </ScrollView>
  );
}

function CollapsibleSection({ title, children, defaultOpen = false }: {
  title: string;
  children: React.ReactNode;
  defaultOpen?: boolean;
}) {
  const [isOpen, setIsOpen] = useState(defaultOpen);
  const { t } = useTranslation();

  return (
    <Collapsible open={isOpen} onOpenChange={setIsOpen}>
      <Button
        chromeless
        justifyContent="flex-start"
        padding={0}
        height="auto"
        fontWeight="$6"
        textAlign="left"
        onPress={() => setIsOpen(!isOpen)}
      >
        <XStack alignItems="center" gap="$2">
          <Square>
            {isOpen ? (
              <ChevronDown size={16} />
            ) : (
              <ChevronRight size={16} />
            )}
          </Square>
          <Text fontWeight="$6">{title}</Text>
        </XStack>
      </Button>
      <YStack marginTop="$2" display={isOpen ? "flex" : "none"}>
        {children}
      </YStack>
    </Collapsible>
  );
}

export function MarkdownRenderer({ 
  content, 
  allowCopy = true,
  allowCollapse = true 
}: MarkdownRendererProps) {
  const { t } = useTranslation();
  const [processedContent, setProcessedContent] = useState<React.ReactNode[]>([]);

  useEffect(() => {
    const processMarkdown = (text: string): React.ReactNode[] => {
      const elements: React.ReactNode[] = [];
      let key = 0;

      // Split by code blocks first
      const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
      const parts = text.split(codeBlockRegex);

      for (let i = 0; i < parts.length; i += 3) {
        const beforeCode = parts[i];
        const language = parts[i + 1] || 'text';
        const code = parts[i + 2];

        // Process text before code block
        if (beforeCode) {
          const textElements = processText(beforeCode, key);
          elements.push(...textElements);
          key += textElements.length;
        }

        // Add code block
        if (code) {
          elements.push(
            <CodeBlock
              key={`code-${key++}`}
              language={language}
              code={code.trim()}
              allowCopy={allowCopy}
            />
          );
        }
      }

      return elements;
    };

    const processText = (text: string, startKey: number): React.ReactNode[] => {
      const elements: React.ReactNode[] = [];
      let key = startKey;

      // Process headers
      const headerRegex = /^(#{1,6})\s+(.+)$/gm;
      let lastIndex = 0;
      let match;

      while ((match = headerRegex.exec(text)) !== null) {
        // Add text before header
        if (match.index > lastIndex) {
          const beforeText = text.slice(lastIndex, match.index);
          elements.push(...processInlineText(beforeText, key));
          key += beforeText.split('\n').length;
        }

        // Add header
        const level = match[1].length;
        const headerText = match[2];
        
        elements.push(
          <Text
            key={`header-${key++}`}
            fontWeight="$8"
            marginVertical="$3"
            fontSize={level === 1 ? '$7' : level === 2 ? '$6' : level === 3 ? '$5' : level === 4 ? '$4' : level === 5 ? '$3' : '$2'}
          >
            {processInlineText(headerText, key)}
          </Text>
        );
        key += headerText.split('\n').length;
        lastIndex = match.index + match[0].length;
      }

      // Add remaining text
      if (lastIndex < text.length) {
        const remainingText = text.slice(lastIndex);
        elements.push(...processInlineText(remainingText, key));
      }

      return elements;
    };

    const processInlineText = (text: string, startKey: number): React.ReactNode[] => {
      const elements: React.ReactNode[] = [];
      let key = startKey;

      // Process links
      const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
      let lastIndex = 0;
      let match;

      while ((match = linkRegex.exec(text)) !== null) {
        // Add text before link
        if (match.index > lastIndex) {
          const beforeText = text.slice(lastIndex, match.index);
          elements.push(beforeText);
        }

        // Add link
        elements.push(
          <Text
            key={`link-${key++}`}
            color="$blue10"
            hoverStyle={{ textDecorationLine: "underline" }}
            onPress={() => window.open(match[2], '_blank')}
          >
            <XStack alignItems="center" gap="$1" display="inline-flex">
              <Text color="$blue10">{match[1]}</Text>
              <ExternalLink size={12} color="$blue10" />
            </XStack>
          </Text>
        );
        lastIndex = match.index + match[0].length;
      }

      // Add remaining text
      if (lastIndex < text.length) {
        const remainingText = text.slice(lastIndex);
        elements.push(remainingText);
      }

      // Process bold and italic
      const processedElements = elements.map((element, index) => {
        if (typeof element === 'string') {
          return processBoldItalic(element, key + index);
        }
        return element;
      });

      return processedElements.flat();
    };

    const processBoldItalic = (text: string, startKey: number): React.ReactNode[] => {
      const elements: React.ReactNode[] = [];
      let key = startKey;

      // Process bold text
      const boldRegex = /\*\*(.*?)\*\*/g;
      let lastIndex = 0;
      let match;

      while ((match = boldRegex.exec(text)) !== null) {
        // Add text before bold
        if (match.index > lastIndex) {
          const beforeText = text.slice(lastIndex, match.index);
          elements.push(beforeText);
        }

        // Add bold text
        elements.push(
          <Text key={`bold-${key++}`} fontWeight="$8">
            {match[1]}
          </Text>
        );
        lastIndex = match.index + match[0].length;
      }

      // Add remaining text
      if (lastIndex < text.length) {
        const remainingText = text.slice(lastIndex);
        elements.push(remainingText);
      }

      return elements;
    };

    const processed = processMarkdown(content);
    setProcessedContent(processed);
  }, [content, allowCopy]);

  return (
    <YStack space="$2">
      {processedContent.map((element, index) => (
        <React.Fragment key={index}>
          {element}
        </React.Fragment>
      ))}
    </YStack>
  );
}
