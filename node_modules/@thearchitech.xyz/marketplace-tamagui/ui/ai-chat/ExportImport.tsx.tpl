'use client';

import React, { useState, useCallback, useRef } from 'react';
import { useTranslation } from '@/lib/i18n';
import { 
  Download, 
  Upload, 
  FileText, 
  FileJson, 
  FileImage, 
  File as FileIcon,
  CheckCircle,
  AlertCircle,
  X,
  Settings,
  Calendar,
  MessageSquare,
  Database,
  Archive,
  Share2,
  Copy,
  Trash2
} from 'lucide-react-native';

import {
  YStack,
  XStack,
  Button,
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  Badge,
  Progress,
  Text,
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Checkbox,
  Separator,
  Theme,
  Square,
  ScrollView
} from 'tamagui';

// Define types if not imported
type ExportFormat = 'json' | 'markdown' | 'pdf' | 'txt';
type ImportFormat = 'json' | 'markdown' | 'txt';

interface ExportOptions {
  format: ExportFormat;
  includeMetadata: boolean;
  includeAttachments: boolean;
}

interface ImportOptions {
  format: ImportFormat;
  mergeWithExisting: boolean;
  createNewConversation: boolean;
}

interface Conversation {
  id: string;
  title: string;
  messageCount: number;
  updatedAt: string;
  status: string;
}

export interface ExportImportProps {
  conversations: Conversation[];
  onExport?: (conversations: Conversation[], options: ExportOptions) => Promise<string>;
  onImport?: (file: File, options: ImportOptions) => Promise<Conversation[]>;
  onDeleteConversations?: (conversationIds: string[]) => Promise<void>;
  onClearAll?: () => Promise<void>;
}

export function ExportImport({
  conversations,
  onExport,
  onImport,
  onDeleteConversations,
  onClearAll,
}: ExportImportProps) {
  const { t } = useTranslation();
  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);
  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isClearDialogOpen, setIsClearDialogOpen] = useState(false);
  
  const [selectedConversations, setSelectedConversations] = useState<Set<string>>(new Set());
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    format: 'json',
    includeMetadata: true,
    includeAttachments: false,
  });
  const [importOptions, setImportOptions] = useState<ImportOptions>({
    format: 'json',
    mergeWithExisting: true,
    createNewConversation: false,
  });
  
  const [isExporting, setIsExporting] = useState(false);
  const [isImporting, setIsImporting] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [isClearing, setIsClearing] = useState(false);
  
  const [exportProgress, setExportProgress] = useState(0);
  const [importProgress, setImportProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Handle conversation selection
  const handleConversationSelect = useCallback((conversationId: string, selected: boolean) => {
    setSelectedConversations(prev => {
      const newSet = new Set(prev);
      if (selected) {
        newSet.add(conversationId);
      } else {
        newSet.delete(conversationId);
      }
      return newSet;
    });
  }, []);

  const handleSelectAll = useCallback(() => {
    if (selectedConversations.size === conversations.length) {
      setSelectedConversations(new Set());
    } else {
      setSelectedConversations(new Set(conversations.map(c => c.id)));
    }
  }, [conversations, selectedConversations.size]);

  // Export functionality
  const handleExport = useCallback(async () => {
    if (selectedConversations.size === 0) {
      setError(t('errors.selectConversationsToExport'));
      return;
    }

    setIsExporting(true);
    setError(null);
    setExportProgress(0);

    try {
      const conversationsToExport = conversations.filter(c => selectedConversations.has(c.id));
      
      // Simulate progress
      const progressInterval = setInterval(() => {
        setExportProgress(prev => Math.min(prev + 10, 90));
      }, 100);

      const result = await onExport?.(conversationsToExport, exportOptions);
      
      clearInterval(progressInterval);
      setExportProgress(100);
      
      // Download the file
      const blob = new Blob([result], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chat-export-${new Date().toISOString().split('T')[0]}.${exportOptions.format}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      setSuccess(t('chat.exportSuccess', { count: conversationsToExport.length }));
      setIsExportDialogOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : t('errors.exportFailed'));
    } finally {
      setIsExporting(false);
      setExportProgress(0);
    }
  }, [selectedConversations, conversations, exportOptions, onExport, t]);

  // Import functionality
  const handleImport = useCallback(async (file: File) => {
    setIsImporting(true);
    setError(null);
    setImportProgress(0);

    try {
      // Simulate progress
      const progressInterval = setInterval(() => {
        setImportProgress(prev => Math.min(prev + 20, 90));
      }, 200);

      const result = await onImport?.(file, importOptions);
      
      clearInterval(progressInterval);
      setImportProgress(100);
      
      setSuccess(t('chat.importSuccess', { count: result.length }));
      setIsImportDialogOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : t('errors.importFailed'));
    } finally {
      setIsImporting(false);
      setImportProgress(0);
    }
  }, [importOptions, onImport, t]);

  // Delete functionality
  const handleDelete = useCallback(async () => {
    if (selectedConversations.size === 0) {
      setError(t('errors.selectConversationsToDelete'));
      return;
    }

    setIsDeleting(true);
    setError(null);

    try {
      await onDeleteConversations?.(Array.from(selectedConversations));
      setSuccess(t('chat.deleteSuccess', { count: selectedConversations.size }));
      setSelectedConversations(new Set());
      setIsDeleteDialogOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : t('errors.deleteFailed'));
    } finally {
      setIsDeleting(false);
    }
  }, [selectedConversations, onDeleteConversations, t]);

  // Clear all functionality
  const handleClearAll = useCallback(async () => {
    setIsClearing(true);
    setError(null);

    try {
      await onClearAll?.();
      setSuccess(t('chat.clearAllSuccess'));
      setSelectedConversations(new Set());
      setIsClearDialogOpen(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : t('errors.clearAllFailed'));
    } finally {
      setIsClearing(false);
    }
  }, [onClearAll, t]);

  // File input handler
  const handleFileInput = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleImport(file);
    }
  }, [handleImport]);

  const getFormatIcon = (format: ExportFormat | ImportFormat) => {
    switch (format) {
      case 'json':
        return <FileJson size={16} />;
      case 'markdown':
        return <FileText size={16} />;
      case 'pdf':
        return <FileImage size={16} />;
      case 'txt':
        return <FileText size={16} />;
      default:
        return <FileIcon size={16} />;
    }
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const formatDate = (date: string): string => {
    return new Date(date).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <YStack space="$6">
      {/* Header */}
      <XStack alignItems="center" justifyContent="space-between">
        <Text fontSize="$5" fontWeight="$6">{t('chat.exportImport')}</Text>
        <XStack gap="$2">
          <Button
            variant="outlined"
            onPress={() => setIsExportDialogOpen(true)}
            disabled={conversations.length === 0}
          >
            <XStack alignItems="center" gap="$2">
              <Download size={16} />
              <Text>{t('chat.export')}</Text>
            </XStack>
          </Button>
          <Button
            variant="outlined"
            onPress={() => fileInputRef.current?.click()}
          >
            <XStack alignItems="center" gap="$2">
              <Upload size={16} />
              <Text>{t('chat.import')}</Text>
            </XStack>
          </Button>
          <input
            ref={fileInputRef}
            type="file"
            accept=".json,.md,.txt"
            onChange={handleFileInput}
            style={{ display: 'none' }}
          />
        </XStack>
      </XStack>

      {/* Conversations List */}
      <Card bordered>
        <CardHeader>
          <XStack alignItems="center" justifyContent="space-between">
            <CardTitle>{t('chat.conversations')}</CardTitle>
            <XStack gap="$2">
              <Button
                variant="outlined"
                size="$2"
                onPress={handleSelectAll}
              >
                {selectedConversations.size === conversations.length 
                  ? t('chat.deselectAll') 
                  : t('chat.selectAll')
                }
              </Button>
              {selectedConversations.size > 0 && (
                <Button
                  theme="red"
                  size="$2"
                  onPress={() => setIsDeleteDialogOpen(true)}
                >
                  <XStack alignItems="center" gap="$2">
                    <Trash2 size={16} />
                    <Text>{t('chat.deleteSelected')}</Text>
                  </XStack>
                </Button>
              )}
            </XStack>
          </XStack>
        </CardHeader>
        <CardContent>
          {conversations.length === 0 ? (
            <YStack height={128} alignItems="center" justifyContent="center">
              <MessageSquare size={32} color="$colorFocus" />
              <Text color="$colorFocus" marginTop="$2">
                {t('chat.noConversationsToExport')}
              </Text>
            </YStack>
          ) : (
            <YStack space="$2">
              {conversations.map((conversation) => (
                <XStack
                  key={conversation.id}
                  alignItems="center"
                  gap="$3"
                  padding="$3"
                  borderRadius="$3"
                  borderWidth={1}
                  borderColor={selectedConversations.has(conversation.id) ? "$blue8" : "$borderColor"}
                  backgroundColor={selectedConversations.has(conversation.id) ? "$blue2" : "transparent"}
                >
                  <Checkbox
                    checked={selectedConversations.has(conversation.id)}
                    onCheckedChange={(checked) => handleConversationSelect(conversation.id, !!checked)}
                  />
                  <YStack flex={1} minWidth={0}>
                    <Text fontWeight="$6" fontSize="$3" numberOfLines={1} ellipsizeMode="tail">
                      {conversation.title}
                    </Text>
                    <XStack alignItems="center" gap="$2" flexWrap="wrap">
                      <XStack alignItems="center" gap="$1">
                        <MessageSquare size={12} color="$colorFocus" />
                        <Text fontSize="$1" color="$colorFocus">
                          {conversation.messageCount} {t('chat.messages')}
                        </Text>
                      </XStack>
                      <XStack alignItems="center" gap="$1">
                        <Calendar size={12} color="$colorFocus" />
                        <Text fontSize="$1" color="$colorFocus">
                          {formatDate(conversation.updatedAt)}
                        </Text>
                      </XStack>
                    </XStack>
                  </YStack>
                  <Badge variant="outline" size="$1">
                    {conversation.status}
                  </Badge>
                </XStack>
              ))}
            </YStack>
          )}
        </CardContent>
      </Card>

      {/* Danger Zone */}
      <Card bordered borderColor="$red8">
        <CardHeader>
          <CardTitle color="$red10">{t('chat.dangerZone')}</CardTitle>
        </CardHeader>
        <CardContent>
          <XStack alignItems="center" justifyContent="space-between">
            <YStack>
              <Text fontWeight="$6">{t('chat.clearAllConversations')}</Text>
              <Text fontSize="$2" color="$colorFocus">
                {t('chat.clearAllWarning')}
              </Text>
            </YStack>
            <Button
              theme="red"
              onPress={() => setIsClearDialogOpen(true)}
              disabled={conversations.length === 0}
            >
              <XStack alignItems="center" gap="$2">
                <Trash2 size={16} />
                <Text>{t('chat.clearAll')}</Text>
              </XStack>
            </Button>
          </XStack>
        </CardContent>
      </Card>

      {/* Status Messages */}
      {error && (
        <XStack 
          alignItems="center" 
          gap="$2" 
          padding="$3" 
          backgroundColor="$red2" 
          borderWidth={1} 
          borderColor="$red6" 
          borderRadius="$2"
        >
          <AlertCircle size={16} color="$red10" />
          <Text color="$red10" fontSize="$2">{error}</Text>
          <Button
            chromeless
            size="$1"
            circular
            marginLeft="auto"
            onPress={() => setError(null)}
          >
            <X size={12} />
          </Button>
        </XStack>
      )}

      {success && (
        <XStack 
          alignItems="center" 
          gap="$2" 
          padding="$3" 
          backgroundColor="$green2" 
          borderWidth={1} 
          borderColor="$green6" 
          borderRadius="$2"
        >
          <CheckCircle size={16} color="$green10" />
          <Text color="$green10" fontSize="$2">{success}</Text>
          <Button
            chromeless
            size="$1"
            circular
            marginLeft="auto"
            onPress={() => setSuccess(null)}
          >
            <X size={12} />
          </Button>
        </XStack>
      )}

      {/* Export Dialog */}
      <Dialog open={isExportDialogOpen} onOpenChange={setIsExportDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>{t('chat.exportConversations')}</DialogTitle>
          </DialogHeader>
          
          <YStack space="$4" paddingVertical="$4">
            <YStack>
              <Text fontWeight="$6" marginBottom="$2" fontSize="$3">
                {t('chat.exportFormat')}
              </Text>
              <Select
                value={exportOptions.format}
                onValueChange={(value: string) => 
                  setExportOptions(prev => ({ ...prev, format: value as ExportFormat }))
                }
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="json">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('json')}
                      <Text>JSON</Text>
                    </XStack>
                  </SelectItem>
                  <SelectItem value="markdown">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('markdown')}
                      <Text>Markdown</Text>
                    </XStack>
                  </SelectItem>
                  <SelectItem value="pdf">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('pdf')}
                      <Text>PDF</Text>
                    </XStack>
                  </SelectItem>
                  <SelectItem value="txt">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('txt')}
                      <Text>Text</Text>
                    </XStack>
                  </SelectItem>
                </SelectContent>
              </Select>
            </YStack>
            
            <YStack space="$3">
              <XStack alignItems="center" gap="$2">
                <Checkbox
                  id="includeMetadata"
                  checked={exportOptions.includeMetadata}
                  onCheckedChange={(checked) => 
                    setExportOptions(prev => ({ ...prev, includeMetadata: !!checked }))
                  }
                />
                <Text fontSize="$2" onPress={() => 
                  setExportOptions(prev => ({ ...prev, includeMetadata: !prev.includeMetadata }))
                }>
                  {t('chat.includeMetadata')}
                </Text>
              </XStack>
              
              <XStack alignItems="center" gap="$2">
                <Checkbox
                  id="includeAttachments"
                  checked={exportOptions.includeAttachments}
                  onCheckedChange={(checked) => 
                    setExportOptions(prev => ({ ...prev, includeAttachments: !!checked }))
                  }
                />
                <Text fontSize="$2" onPress={() => 
                  setExportOptions(prev => ({ ...prev, includeAttachments: !prev.includeAttachments }))
                }>
                  {t('chat.includeAttachments')}
                </Text>
              </XStack>
            </YStack>
            
            {exportProgress > 0 && (
              <YStack space="$2">
                <XStack alignItems="center" justifyContent="space-between">
                  <Text fontSize="$2">{t('chat.exporting')}</Text>
                  <Text fontSize="$2">{exportProgress}%</Text>
                </XStack>
                <Progress value={exportProgress} />
              </YStack>
            )}
          </YStack>
          
          <DialogFooter>
            <XStack gap="$3" justifyContent="flex-end">
              <Button
                variant="outlined"
                onPress={() => setIsExportDialogOpen(false)}
                disabled={isExporting}
              >
                {t('common.cancel')}
              </Button>
              <Button
                onPress={handleExport}
                disabled={isExporting || selectedConversations.size === 0}
              >
                {isExporting ? t('chat.exporting') : t('chat.export')}
              </Button>
            </XStack>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Import Dialog */}
      <Dialog open={isImportDialogOpen} onOpenChange={setIsImportDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>{t('chat.importConversations')}</DialogTitle>
          </DialogHeader>
          
          <YStack space="$4" paddingVertical="$4">
            <YStack>
              <Text fontWeight="$6" marginBottom="$2" fontSize="$3">
                {t('chat.importFormat')}
              </Text>
              <Select
                value={importOptions.format}
                onValueChange={(value: string) => 
                  setImportOptions(prev => ({ ...prev, format: value as ImportFormat }))
                }
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="json">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('json')}
                      <Text>JSON</Text>
                    </XStack>
                  </SelectItem>
                  <SelectItem value="markdown">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('markdown')}
                      <Text>Markdown</Text>
                    </XStack>
                  </SelectItem>
                  <SelectItem value="txt">
                    <XStack alignItems="center" gap="$2">
                      {getFormatIcon('txt')}
                      <Text>Text</Text>
                    </XStack>
                  </SelectItem>
                </SelectContent>
              </Select>
            </YStack>
            
            <YStack space="$3">
              <XStack alignItems="center" gap="$2">
                <Checkbox
                  id="mergeWithExisting"
                  checked={importOptions.mergeWithExisting}
                  onCheckedChange={(checked) => 
                    setImportOptions(prev => ({ ...prev, mergeWithExisting: !!checked }))
                  }
                />
                <Text fontSize="$2" onPress={() => 
                  setImportOptions(prev => ({ ...prev, mergeWithExisting: !prev.mergeWithExisting }))
                }>
                  {t('chat.mergeWithExisting')}
                </Text>
              </XStack>
              
              <XStack alignItems="center" gap="$2">
                <Checkbox
                  id="createNewConversation"
                  checked={importOptions.createNewConversation}
                  onCheckedChange={(checked) => 
                    setImportOptions(prev => ({ ...prev, createNewConversation: !!checked }))
                  }
                />
                <Text fontSize="$2" onPress={() => 
                  setImportOptions(prev => ({ ...prev, createNewConversation: !prev.createNewConversation }))
                }>
                  {t('chat.createNewConversation')}
                </Text>
              </XStack>
            </YStack>
            
            {importProgress > 0 && (
              <YStack space="$2">
                <XStack alignItems="center" justifyContent="space-between">
                  <Text fontSize="$2">{t('chat.importing')}</Text>
                  <Text fontSize="$2">{importProgress}%</Text>
                </XStack>
                <Progress value={importProgress} />
              </YStack>
            )}
          </YStack>
          
          <DialogFooter>
            <XStack gap="$3" justifyContent="flex-end">
              <Button
                variant="outlined"
                onPress={() => setIsImportDialogOpen(false)}
                disabled={isImporting}
              >
                {t('common.cancel')}
              </Button>
              <Button
                onPress={() => fileInputRef.current?.click()}
                disabled={isImporting}
              >
                {isImporting ? t('chat.importing') : t('chat.selectFile')}
              </Button>
            </XStack>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Dialog */}
      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>{t('chat.deleteConversations')}</DialogTitle>
          </DialogHeader>
          
          <YStack space="$4" paddingVertical="$4">
            <Text color="$colorFocus" fontSize="$2">
              {t('chat.deleteWarning', { count: selectedConversations.size })}
            </Text>
            
            <YStack space="$2" maxHeight={200}>
              <ScrollView showsVerticalScrollIndicator={true}>
                {Array.from(selectedConversations).map(conversationId => {
                  const conversation = conversations.find(c => c.id === conversationId);
                  return conversation ? (
                    <XStack 
                      key={conversationId} 
                      alignItems="center" 
                      gap="$2" 
                      padding="$2" 
                      backgroundColor="$backgroundHover" 
                      borderRadius="$2"
                      marginBottom="$1"
                    >
                      <MessageSquare size={16} />
                      <Text fontSize="$2">{conversation.title}</Text>
                    </XStack>
                  ) : null;
                })}
              </ScrollView>
            </YStack>
          </YStack>
          
          <DialogFooter>
            <XStack gap="$3" justifyContent="flex-end">
              <Button
                variant="outlined"
                onPress={() => setIsDeleteDialogOpen(false)}
                disabled={isDeleting}
              >
                {t('common.cancel')}
              </Button>
              <Button
                theme="red"
                onPress={handleDelete}
                disabled={isDeleting}
              >
                {isDeleting ? t('common.deleting') : t('common.delete')}
              </Button>
            </XStack>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Clear All Dialog */}
      <Dialog open={isClearDialogOpen} onOpenChange={setIsClearDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>{t('chat.clearAllConversations')}</DialogTitle>
          </DialogHeader>
          
          <YStack space="$4" paddingVertical="$4">
            <Text color="$colorFocus" fontSize="$2">
              {t('chat.clearAllConfirmation', { count: conversations.length })}
            </Text>
          </YStack>
          
          <DialogFooter>
            <XStack gap="$3" justifyContent="flex-end">
              <Button
                variant="outlined"
                onPress={() => setIsClearDialogOpen(false)}
                disabled={isClearing}
              >
                {t('common.cancel')}
              </Button>
              <Button
                theme="red"
                onPress={handleClearAll}
                disabled={isClearing}
              >
                {isClearing ? t('chat.clearing') : t('chat.clearAll')}
              </Button>
            </XStack>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </YStack>
  );
}
