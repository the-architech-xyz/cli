'use client';

import React, { useState, useCallback, useMemo } from 'react';
import { useTranslation } from '@/lib/i18n';
import { 
  Plus, 
  Search, 
  Edit3, 
  Trash2, 
  Copy, 
  Star, 
  StarOff,
  Tag,
  Filter,
  MoreVertical,
  ChevronDown,
  ChevronUp,
  Save,
  X,
  Lightbulb,
  Code,
  MessageSquare,
  Zap
} from 'lucide-react-native';

import {
  YStack,
  XStack,
  Button,
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  Input,
  TextArea,
  Badge,
  ScrollView,
  Text,
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
  Theme,
  Square
} from 'tamagui';

// Define types if not imported
interface CustomPrompt {
  id: string;
  name: string;
  content: string;
  category?: string;
  tags?: string[];
  createdAt: string;
  updatedAt: string;
}

interface CustomPromptCategory {
  id: string;
  name: string;
  color?: string;
}

export interface CustomPromptsProps {
  onPromptSelect?: (prompt: string) => void;
  onPromptCreate?: (prompt: CustomPrompt) => void;
  onPromptUpdate?: (id: string, prompt: CustomPrompt) => void;
  onPromptDelete?: (id: string) => void;
  onCategoryCreate?: (category: CustomPromptCategory) => void;
  onCategoryUpdate?: (id: string, category: CustomPromptCategory) => void;
  onCategoryDelete?: (id: string) => void;
  initialPrompts?: CustomPrompt[];
  initialCategories?: CustomPromptCategory[];
}

export function CustomPrompts({
  onPromptSelect,
  onPromptCreate,
  onPromptUpdate,
  onPromptDelete,
  onCategoryCreate,
  onCategoryUpdate,
  onCategoryDelete,
  initialPrompts = [],
  initialCategories = [],
}: CustomPromptsProps) {
  const { t } = useTranslation();
  const [prompts, setPrompts] = useState<CustomPrompt[]>(initialPrompts);
  const [categories, setCategories] = useState<CustomPromptCategory[]>(initialCategories);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [showFilters, setShowFilters] = useState(false);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingPrompt, setEditingPrompt] = useState<CustomPrompt | null>(null);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());

  // Form state for create/edit
  const [formData, setFormData] = useState({
    name: '',
    content: '',
    category: '',
    tags: [] as string[],
  });

  // Filter prompts based on search and category
  const filteredPrompts = useMemo(() => {
    let filtered = prompts;

    // Apply search filter
    if (searchQuery) {
      filtered = filtered.filter(prompt =>
        prompt.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        prompt.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
        prompt.tags?.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()))
      );
    }

    // Apply category filter
    if (selectedCategory) {
      filtered = filtered.filter(prompt => prompt.category === selectedCategory);
    }

    return filtered;
  }, [prompts, searchQuery, selectedCategory]);

  // Group prompts by category
  const groupedPrompts = useMemo(() => {
    const groups: Record<string, CustomPrompt[]> = {};
    
    filteredPrompts.forEach(prompt => {
      const category = prompt.category || t('chat.uncategorized');
      if (!groups[category]) {
        groups[category] = [];
      }
      groups[category].push(prompt);
    });

    return groups;
  }, [filteredPrompts, t]);

  // Handle form submission
  const handleSubmit = useCallback(() => {
    if (!formData.name.trim() || !formData.content.trim()) {
      return;
    }

    const promptData: CustomPrompt = {
      id: editingPrompt?.id || Date.now().toString(),
      name: formData.name.trim(),
      content: formData.content.trim(),
      category: formData.category || undefined,
      tags: formData.tags,
      createdAt: editingPrompt?.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    if (editingPrompt) {
      setPrompts(prev => prev.map(p => p.id === editingPrompt.id ? promptData : p));
      onPromptUpdate?.(editingPrompt.id, promptData);
      setIsEditDialogOpen(false);
    } else {
      setPrompts(prev => [...prev, promptData]);
      onPromptCreate?.(promptData);
      setIsCreateDialogOpen(false);
    }

    // Reset form
    setFormData({ name: '', content: '', category: '', tags: [] });
    setEditingPrompt(null);
  }, [formData, editingPrompt, onPromptCreate, onPromptUpdate]);

  // Handle prompt actions
  const handlePromptSelect = useCallback((prompt: CustomPrompt) => {
    onPromptSelect?.(prompt.content);
  }, [onPromptSelect]);

  const handlePromptEdit = useCallback((prompt: CustomPrompt) => {
    setEditingPrompt(prompt);
    setFormData({
      name: prompt.name,
      content: prompt.content,
      category: prompt.category || '',
      tags: prompt.tags || [],
    });
    setIsEditDialogOpen(true);
  }, []);

  const handlePromptDelete = useCallback((promptId: string) => {
    setPrompts(prev => prev.filter(p => p.id !== promptId));
    onPromptDelete?.(promptId);
  }, [onPromptDelete]);

  const handlePromptCopy = useCallback((prompt: CustomPrompt) => {
    navigator.clipboard.writeText(prompt.content);
  }, []);

  const handleCategoryToggle = useCallback((categoryId: string) => {
    setExpandedCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(categoryId)) {
        newSet.delete(categoryId);
      } else {
        newSet.add(categoryId);
      }
      return newSet;
    });
  }, []);

  const handleTagAdd = useCallback((tag: string) => {
    if (tag.trim() && !formData.tags.includes(tag.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, tag.trim()],
      }));
    }
  }, [formData.tags]);

  const handleTagRemove = useCallback((tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove),
    }));
  }, []);

  const getCategoryColor = (categoryId: string) => {
    const category = categories.find(c => c.id === categoryId);
    return category?.color || 'gray';
  };

  const getPromptIcon = (prompt: CustomPrompt) => {
    if (prompt.content.includes('code') || prompt.content.includes('```')) {
      return <Code size={16} />;
    }
    if (prompt.content.includes('creative') || prompt.content.includes('story')) {
      return <Lightbulb size={16} />;
    }
    if (prompt.content.includes('chat') || prompt.content.includes('conversation')) {
      return <MessageSquare size={16} />;
    }
    return <Zap size={16} />;
  };

  return (
    <YStack space="$4">
      {/* Header */}
      <XStack alignItems="center" justifyContent="space-between">
        <Text fontSize="$5" fontWeight="$6">{t('chat.customPrompts')}</Text>
        <Button onPress={() => setIsCreateDialogOpen(true)}>
          <XStack alignItems="center" gap="$2">
            <Plus size={16} />
            <Text>{t('chat.newPrompt')}</Text>
          </XStack>
        </Button>
      </XStack>

      {/* Search and Filters */}
      <YStack space="$3">
        <XStack position="relative">
          <XStack position="absolute" left="$3" top="50%" alignItems="center" transform={[{ translateY: -8 }]}>
            <Search size={16} color="$colorFocus" />
          </XStack>
          <Input
            placeholder={t('chat.searchPrompts')}
            value={searchQuery}
            onChangeText={setSearchQuery}
            paddingLeft="$10"
            flex={1}
          />
        </XStack>
        
        <XStack alignItems="center" gap="$2">
          <Button
            variant="outlined"
            size="$2"
            onPress={() => setShowFilters(!showFilters)}
          >
            <XStack alignItems="center" gap="$2">
              <Filter size={16} />
              <Text>{t('common.filters')}</Text>
              {showFilters ? (
                <ChevronUp size={16} />
              ) : (
                <ChevronDown size={16} />
              )}
            </XStack>
          </Button>
          
          {selectedCategory && (
            <Button
              chromeless
              size="$2"
              onPress={() => setSelectedCategory(null)}
            >
              <Text>{t('chat.clearCategory')}</Text>
            </Button>
          )}
        </XStack>

        {/* Filters Panel */}
        {showFilters && (
          <YStack 
            padding="$4" 
            backgroundColor="$backgroundHover" 
            borderRadius="$2"
            space="$3"
          >
            <YStack>
              <Text fontWeight="$6" marginBottom="$2">{t('chat.category')}</Text>
              <Select
                value={selectedCategory || ''}
                onValueChange={(value) => setSelectedCategory(value || null)}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">
                    <Text>{t('chat.allCategories')}</Text>
                  </SelectItem>
                  {categories.map(category => (
                    <SelectItem key={category.id} value={category.id}>
                      <Text>{category.name}</Text>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </YStack>
          </YStack>
        )}
      </YStack>

      {/* Prompts List */}
      <ScrollView height={384} showsVerticalScrollIndicator={true}>
        <YStack space="$4">
          {Object.keys(groupedPrompts).length === 0 ? (
            <YStack height={256} alignItems="center" justifyContent="center">
              <Lightbulb size={48} color="$colorFocus" />
              <Text fontWeight="$6" fontSize="$5" marginTop="$4" marginBottom="$2">
                {searchQuery ? t('chat.noPromptsFound') : t('chat.noPromptsYet')}
              </Text>
              <Text color="$colorFocus" textAlign="center" marginBottom="$4">
                {searchQuery 
                  ? t('chat.adjustSearchTerms')
                  : t('chat.createFirstPrompt')
                }
              </Text>
              {!searchQuery && (
                <Button onPress={() => setIsCreateDialogOpen(true)}>
                  <XStack alignItems="center" gap="$2">
                    <Plus size={16} />
                    <Text>{t('chat.createFirstPrompt')}</Text>
                  </XStack>
                </Button>
              )}
            </YStack>
          ) : (
            Object.entries(groupedPrompts).map(([category, categoryPrompts]) => (
              <YStack key={category} space="$2">
                {/* Category Header */}
                <XStack alignItems="center" gap="$2">
                  <Button
                    chromeless
                    size="$1"
                    padding={0}
                    height="auto"
                    onPress={() => handleCategoryToggle(category)}
                  >
                    <Square>
                      {expandedCategories.has(category) ? (
                        <ChevronDown size={16} />
                      ) : (
                        <ChevronUp size={16} />
                      )}
                    </Square>
                  </Button>
                  <Badge theme={getCategoryColor(category) as any}>
                    <Text fontSize="$1">{category}</Text>
                  </Badge>
                  <Text fontSize="$2" color="$colorFocus">
                    {categoryPrompts.length} {categoryPrompts.length !== 1 
                      ? t('chat.prompts') 
                      : t('chat.prompt')
                    }
                  </Text>
                </XStack>

                {/* Category Prompts */}
                {expandedCategories.has(category) && (
                  <XStack flexWrap="wrap" gap="$3">
                    {categoryPrompts.map((prompt) => (
                      <Card 
                        key={prompt.id} 
                        elevate
                        bordered
                        width={{ sm: "100%", md: "48%", lg: "32%" }}
                        animation="bouncy"
                        scale={1}
                        hoverStyle={{ scale: 1.02 }}
                        pressStyle={{ scale: 0.98 }}
                      >
                        <CardHeader paddingBottom="$2">
                          <XStack alignItems="flex-start" justifyContent="space-between">
                            <XStack alignItems="center" gap="$2">
                              <Square>{getPromptIcon(prompt)}</Square>
                              <CardTitle>{prompt.name}</CardTitle>
                            </XStack>
                            <DropdownMenu>
                              <DropdownMenuTrigger asChild>
                                <Button
                                  size="$1"
                                  circular
                                  chromeless
                                  opacity={0}
                                  hoverStyle={{ opacity: 1 }}
                                  animation="quick"
                                >
                                  <MoreVertical size={12} />
                                </Button>
                              </DropdownMenuTrigger>
                              <DropdownMenuContent align="end">
                                <DropdownMenuItem onPress={() => handlePromptSelect(prompt)}>
                                  <XStack gap="$2" alignItems="center">
                                    <MessageSquare size={12} />
                                    <Text fontSize="$2">{t('chat.usePrompt')}</Text>
                                  </XStack>
                                </DropdownMenuItem>
                                <DropdownMenuItem onPress={() => handlePromptCopy(prompt)}>
                                  <XStack gap="$2" alignItems="center">
                                    <Copy size={12} />
                                    <Text fontSize="$2">{t('common.copy')}</Text>
                                  </XStack>
                                </DropdownMenuItem>
                                <DropdownMenuSeparator />
                                <DropdownMenuItem onPress={() => handlePromptEdit(prompt)}>
                                  <XStack gap="$2" alignItems="center">
                                    <Edit3 size={12} />
                                    <Text fontSize="$2">{t('common.edit')}</Text>
                                  </XStack>
                                </DropdownMenuItem>
                                <DropdownMenuItem onPress={() => handlePromptDelete(prompt.id)}>
                                  <XStack gap="$2" alignItems="center">
                                    <Trash2 size={12} color="$red10" />
                                    <Text fontSize="$2" color="$red10">{t('common.delete')}</Text>
                                  </XStack>
                                </DropdownMenuItem>
                              </DropdownMenuContent>
                            </DropdownMenu>
                          </XStack>
                        </CardHeader>
                        <CardContent paddingTop={0}>
                          <Text 
                            fontSize="$2" 
                            color="$colorFocus" 
                            numberOfLines={3}
                            ellipsizeMode="tail"
                          >
                            {prompt.content}
                          </Text>
                          {prompt.tags && prompt.tags.length > 0 && (
                            <XStack flexWrap="wrap" gap="$1" marginTop="$2">
                              {prompt.tags.map((tag, index) => (
                                <Badge key={index} variant="outline" size="$1">
                                  <Text fontSize="$1">{tag}</Text>
                                </Badge>
                              ))}
                            </XStack>
                          )}
                        </CardContent>
                      </Card>
                    ))}
                  </XStack>
                )}
              </YStack>
            ))
          )}
        </YStack>
      </ScrollView>

      {/* Create/Edit Dialog */}
      <Dialog 
        open={isCreateDialogOpen || isEditDialogOpen} 
        onOpenChange={(open) => {
          if (!open) {
            setIsCreateDialogOpen(false);
            setIsEditDialogOpen(false);
            setEditingPrompt(null);
            setFormData({ name: '', content: '', category: '', tags: [] });
          }
        }}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {editingPrompt ? t('chat.editPrompt') : t('chat.createNewPrompt')}
            </DialogTitle>
          </DialogHeader>
          
          <YStack space="$4" paddingVertical="$4">
            <YStack>
              <Label htmlFor="name">{t('common.name')}</Label>
              <Input
                id="name"
                placeholder={t('chat.enterPromptName')}
                value={formData.name}
                onChangeText={(text) => setFormData(prev => ({ ...prev, name: text }))}
              />
            </YStack>
            
            <YStack>
              <Label htmlFor="content">{t('common.content')}</Label>
              <TextArea
                id="content"
                placeholder={t('chat.enterPromptContent')}
                value={formData.content}
                onChangeText={(text) => setFormData(prev => ({ ...prev, content: text }))}
                numberOfLines={6}
                minHeight={150}
              />
            </YStack>
            
            <YStack>
              <Label htmlFor="category">{t('chat.category')}</Label>
              <Select
                id="category"
                value={formData.category}
                onValueChange={(value) => setFormData(prev => ({ ...prev, category: value }))}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">
                    <Text>{t('chat.noCategory')}</Text>
                  </SelectItem>
                  {categories.map(category => (
                    <SelectItem key={category.id} value={category.id}>
                      <Text>{category.name}</Text>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </YStack>
            
            <YStack>
              <Label htmlFor="tags">{t('chat.tags')}</Label>
              <YStack space="$2">
                <XStack flexWrap="wrap" gap="$1">
                  {formData.tags.map((tag, index) => (
                    <Badge key={index} variant="outline" size="$1">
                      <XStack alignItems="center" gap="$1">
                        <Text fontSize="$1">{tag}</Text>
                        <Button
                          chromeless
                          size="$1"
                          circular
                          onPress={() => handleTagRemove(tag)}
                        >
                          <X size={8} />
                        </Button>
                      </XStack>
                    </Badge>
                  ))}
                </XStack>
                <Input
                  id="tags"
                  placeholder={t('chat.addTagAndPressEnter')}
                  onKeyDown={(e: any) => {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      handleTagAdd(e.currentTarget.value);
                      e.currentTarget.value = '';
                    }
                  }}
                />
              </YStack>
            </YStack>
          </YStack>
          
          <DialogFooter>
            <XStack gap="$3" justifyContent="flex-end">
              <Button
                variant="outlined"
                onPress={() => {
                  setIsCreateDialogOpen(false);
                  setIsEditDialogOpen(false);
                  setEditingPrompt(null);
                  setFormData({ name: '', content: '', category: '', tags: [] });
                }}
              >
                {t('common.cancel')}
              </Button>
              <Button 
                onPress={handleSubmit} 
                disabled={!formData.name.trim() || !formData.content.trim()}
              >
                <XStack alignItems="center" gap="$2">
                  <Save size={16} />
                  <Text>{editingPrompt ? t('common.update') : t('common.create')}</Text>
                </XStack>
              </Button>
            </XStack>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </YStack>
  );
}

// Helper component for Label to match the design
function Label({ htmlFor, children }: { htmlFor: string; children: React.ReactNode }) {
  return (
    <Text fontWeight="$6" marginBottom="$2" htmlFor={htmlFor}>
      {children}
    </Text>
  );
}
