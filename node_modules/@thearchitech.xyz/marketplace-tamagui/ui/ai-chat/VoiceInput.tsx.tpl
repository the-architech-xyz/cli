'use client';

import React, { useState, useCallback, useEffect, useRef } from 'react';
import { useTranslation } from '@/lib/i18n';
import { 
  Mic, 
  MicOff, 
  Volume2, 
  VolumeX, 
  Play, 
  Pause, 
  Square as SquareIcon, 
  RotateCcw,
  Settings,
  CheckCircle,
  AlertCircle,
  Info,
  X,
  Zap,
  Clock,
  Waveform
} from 'lucide-react-native';

import {
  YStack,
  XStack,
  Button,
  Card,
  CardContent,
  Badge,
  Progress,
  Text,
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Slider,
  Switch,
  Label,
  Theme,
  Square
} from 'tamagui';

export interface VoiceInputProps {
  onTranscription?: (text: string) => void;
  onError?: (error: Error) => void;
  onStart?: () => void;
  onStop?: () => void;
  disabled?: boolean;
  autoStart?: boolean;
  continuous?: boolean;
  language?: string;
  maxDuration?: number;
  showSettings?: boolean;
  showWaveform?: boolean;
}

export interface VoiceSettings {
  language: string;
  continuous: boolean;
  interimResults: boolean;
  maxAlternatives: number;
  maxDuration: number;
  sensitivity: number;
  noiseReduction: boolean;
  autoPunctuation: boolean;
}

// Declare global SpeechRecognition types for TypeScript
declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
  }
}

export function VoiceInput({
  onTranscription,
  onError,
  onStart,
  onStop,
  disabled = false,
  autoStart = false,
  continuous = false,
  language = 'en-US',
  maxDuration = 30000, // 30 seconds
  showSettings = true,
  showWaveform = true,
}: VoiceInputProps) {
  const { t } = useTranslation();
  const [isListening, setIsListening] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [transcript, setTranscript] = useState('');
  const [interimTranscript, setInterimTranscript] = useState('');
  const [isSupported, setIsSupported] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [volume, setVolume] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);

  const recognitionRef = useRef<any | null>(null);
  const mediaStreamRef = useRef<MediaStream | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const animationRef = useRef<number | null>(null);
  const startTimeRef = useRef<number | null>(null);
  const durationIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const [settings, setSettings] = useState<VoiceSettings>({
    language,
    continuous,
    interimResults: true,
    maxAlternatives: 1,
    maxDuration,
    sensitivity: 0.5,
    noiseReduction: true,
    autoPunctuation: true,
  });

  // Check for speech recognition support
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SpeechRecognition) {
        setIsSupported(true);
        recognitionRef.current = new SpeechRecognition();
        setupRecognition();
      } else {
        setIsSupported(false);
        setError(t('errors.speechRecognitionNotSupported'));
      }
    }

    return () => {
      cleanup();
    };
  }, []);

  // Setup speech recognition
  const setupRecognition = useCallback(() => {
    if (!recognitionRef.current) return;

    const recognition = recognitionRef.current;
    
    recognition.continuous = settings.continuous;
    recognition.interimResults = settings.interimResults;
    recognition.lang = settings.language;
    recognition.maxAlternatives = settings.maxAlternatives;

    recognition.onstart = () => {
      setIsListening(true);
      setIsPaused(false);
      setError(null);
      onStart?.();
      startTimeRef.current = Date.now();
      startDurationTimer();
    };

    recognition.onend = () => {
      setIsListening(false);
      setIsPaused(false);
      onStop?.();
      stopDurationTimer();
    };

    recognition.onresult = (event: any) => {
      let finalTranscript = '';
      let interimTranscript = '';

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const result = event.results[i];
        if (result.isFinal) {
          finalTranscript += result[0].transcript;
        } else {
          interimTranscript += result[0].transcript;
        }
      }

      if (finalTranscript) {
        setTranscript(prev => prev + finalTranscript);
        onTranscription?.(finalTranscript);
      }

      setInterimTranscript(interimTranscript);
    };

    recognition.onerror = (event: any) => {
      const errorMessage = getErrorMessage(event.error);
      setError(errorMessage);
      setIsListening(false);
      setIsPaused(false);
      onError?.(new Error(errorMessage));
      stopDurationTimer();
    };

    recognition.onnomatch = () => {
      setError(t('errors.noSpeechDetected'));
    };
  }, [settings, onTranscription, onError, onStart, onStop, t]);

  // Start duration timer
  const startDurationTimer = useCallback(() => {
    durationIntervalRef.current = setInterval(() => {
      if (startTimeRef.current) {
        const elapsed = Date.now() - startTimeRef.current;
        setDuration(elapsed);
        
        if (elapsed >= settings.maxDuration) {
          stopListening();
        }
      }
    }, 100);
  }, [settings.maxDuration]);

  // Stop duration timer
  const stopDurationTimer = useCallback(() => {
    if (durationIntervalRef.current) {
      clearInterval(durationIntervalRef.current);
      durationIntervalRef.current = null;
    }
    setDuration(0);
  }, []);

  // Get error message
  const getErrorMessage = (error: string): string => {
    switch (error) {
      case 'no-speech':
        return t('errors.noSpeechDetected');
      case 'audio-capture':
        return t('errors.noMicrophoneFound');
      case 'not-allowed':
        return t('errors.microphoneAccessDenied');
      case 'network':
        return t('errors.networkError');
      case 'aborted':
        return t('errors.speechRecognitionAborted');
      case 'language-not-supported':
        return t('errors.languageNotSupported');
      default:
        return t('errors.speechRecognitionError', { error });
    }
  };

  // Start listening
  const startListening = useCallback(async () => {
    if (!recognitionRef.current || isListening || disabled) return;

    try {
      setError(null);
      setTranscript('');
      setInterimTranscript('');
      
      // Request microphone permission
      if (typeof navigator !== 'undefined' && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        mediaStreamRef.current = await navigator.mediaDevices.getUserMedia({ 
          audio: { 
            echoCancellation: settings.noiseReduction,
            noiseSuppression: settings.noiseReduction,
            autoGainControl: settings.noiseReduction,
          } 
        });
        
        // Setup audio analysis for waveform
        if (showWaveform) {
          setupAudioAnalysis();
        }
      }

      recognitionRef.current.start();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : t('errors.failedToStartVoiceInput');
      setError(errorMessage);
      onError?.(new Error(errorMessage));
    }
  }, [isListening, disabled, settings, onError, showWaveform, t]);

  // Stop listening
  const stopListening = useCallback(() => {
    if (recognitionRef.current && isListening) {
      recognitionRef.current.stop();
    }
    cleanup();
  }, [isListening]);

  // Pause/Resume listening
  const togglePause = useCallback(() => {
    if (isPaused) {
      // Resume
      if (recognitionRef.current) {
        recognitionRef.current.start();
      }
    } else {
      // Pause
      if (recognitionRef.current) {
        recognitionRef.current.stop();
      }
      setIsPaused(true);
    }
  }, [isPaused]);

  // Setup audio analysis for waveform
  const setupAudioAnalysis = useCallback(() => {
    if (!mediaStreamRef.current || typeof window === 'undefined') return;

    try {
      const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
      if (!AudioContext) return;
      
      audioContextRef.current = new AudioContext();
      analyserRef.current = audioContextRef.current.createAnalyser();
      const source = audioContextRef.current.createMediaStreamSource(mediaStreamRef.current);
      source.connect(analyserRef.current);
      
      analyserRef.current.fftSize = 256;
      const bufferLength = analyserRef.current.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      const updateVolume = () => {
        if (analyserRef.current && isListening) {
          analyserRef.current.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / bufferLength;
          setVolume(average / 255);
          animationRef.current = requestAnimationFrame(updateVolume);
        }
      };

      updateVolume();
    } catch (err) {
      console.warn('Failed to setup audio analysis:', err);
    }
  }, [isListening]);

  // Cleanup
  const cleanup = useCallback(() => {
    if (mediaStreamRef.current) {
      mediaStreamRef.current.getTracks().forEach(track => track.stop());
      mediaStreamRef.current = null;
    }
    
    if (audioContextRef.current) {
      audioContextRef.current.close();
      audioContextRef.current = null;
    }
    
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
    
    stopDurationTimer();
    setVolume(0);
  }, [stopDurationTimer]);

  // Handle settings change
  const handleSettingsChange = useCallback((updates: Partial<VoiceSettings>) => {
    setSettings(prev => ({ ...prev, ...updates }));
  }, []);

  // Format duration
  const formatDuration = (ms: number): string => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Format remaining time
  const getRemainingTime = (): string => {
    const remaining = settings.maxDuration - duration;
    return formatDuration(Math.max(0, remaining));
  };

  // Auto-start effect
  useEffect(() => {
    if (autoStart && isSupported && !disabled) {
      startListening();
    }
  }, [autoStart, isSupported, disabled, startListening]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);

  if (!isSupported) {
    return (
      <Theme name="base">
        <YStack padding="$4" alignItems="center" justifyContent="center">
          <Card width="100%" maxWidth={400}>
            <CardContent padding="$6" alignItems="center">
              <AlertCircle size={32} color="$red10" />
              <Text fontWeight="$6" marginTop="$2" marginBottom="$2">
                {t('chat.voiceInputNotSupported')}
              </Text>
              <Text fontSize="$2" color="$colorFocus" textAlign="center">
                {t('chat.useBrowserWithSpeechRecognition')}
              </Text>
            </CardContent>
          </Card>
        </YStack>
      </Theme>
    );
  }

  return (
    <Theme name="base">
      <YStack space="$4">
        {/* Main Voice Input */}
        <Card bordered>
          <CardContent padding="$4">
            <XStack alignItems="center" gap="$4">
              {/* Voice Button */}
              <Button
                size="$4"
                theme={isListening ? "red" : "accent"}
                circular
                onPress={isListening ? stopListening : startListening}
                disabled={disabled}
                animation="bouncy"
                {...(isListening && { animateOnly: ['transform'], animation: 'pulse' })}
              >
                <Square>
                  {isListening ? (
                    <MicOff size={20} />
                  ) : (
                    <Mic size={20} />
                  )}
                </Square>
              </Button>

              {/* Status and Controls */}
              <YStack flex={1} space="$2">
                <XStack alignItems="center" gap="$2">
                  <Badge theme={isListening ? "accent" : "gray"}>
                    <Text fontSize="$1">
                      {isListening ? t('chat.listening') : t('chat.ready')}
                    </Text>
                  </Badge>
                  {isListening && (
                    <Badge variant="outline">
                      <Text fontSize="$1">{formatDuration(duration)}</Text>
                    </Badge>
                  )}
                  {isListening && (
                    <Badge variant="outline">
                      <Text fontSize="$1">{getRemainingTime()} {t('chat.left')}</Text>
                    </Badge>
                  )}
                </XStack>

                {/* Waveform */}
                {showWaveform && isListening && (
                  <XStack alignItems="center" gap="$1" height={16}>
                    {[...Array(20)].map((_, i) => (
                      <YStack
                        key={i}
                        backgroundColor="$blue10"
                        borderRadius="$full"
                        width={2}
                        height={Math.max(4, volume * 16)}
                        opacity={volume > 0.1 ? 1 : 0.3}
                        animation="quick"
                      />
                    ))}
                  </XStack>
                )}

                {/* Progress Bar */}
                {isListening && (
                  <Progress 
                    value={(duration / settings.maxDuration) * 100} 
                    height={4}
                  />
                )}

                {/* Controls */}
                {isListening && (
                  <XStack alignItems="center" gap="$2">
                    <Button
                      variant="outlined"
                      size="$2"
                      onPress={togglePause}
                    >
                      <XStack alignItems="center" gap="$1">
                        <Square>
                          {isPaused ? <Play size={16} /> : <Pause size={16} />}
                        </Square>
                        <Text>{isPaused ? t('chat.resume') : t('chat.pause')}</Text>
                      </XStack>
                    </Button>
                    <Button
                      variant="outlined"
                      size="$2"
                      onPress={() => {
                        setTranscript('');
                        setInterimTranscript('');
                      }}
                    >
                      <XStack alignItems="center" gap="$1">
                        <RotateCcw size={16} />
                        <Text>{t('common.clear')}</Text>
                      </XStack>
                    </Button>
                  </XStack>
                )}
              </YStack>

              {/* Settings */}
              {showSettings && (
                <Dialog open={isSettingsOpen} onOpenChange={setIsSettingsOpen}>
                  <DialogTrigger asChild>
                    <Button variant="outlined" size="$2">
                      <Settings size={16} />
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>{t('chat.voiceInputSettings')}</DialogTitle>
                    </DialogHeader>
                    <YStack space="$4" paddingVertical="$4">
                      <YStack>
                        <Label>{t('common.language')}</Label>
                        <Select
                          value={settings.language}
                          onValueChange={(value) => handleSettingsChange({ language: value })}
                        >
                          <SelectTrigger>
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="en-US">
                              <Text>English (US)</Text>
                            </SelectItem>
                            <SelectItem value="en-GB">
                              <Text>English (UK)</Text>
                            </SelectItem>
                            <SelectItem value="es-ES">
                              <Text>Spanish</Text>
                            </SelectItem>
                            <SelectItem value="fr-FR">
                              <Text>French</Text>
                            </SelectItem>
                            <SelectItem value="de-DE">
                              <Text>German</Text>
                            </SelectItem>
                            <SelectItem value="it-IT">
                              <Text>Italian</Text>
                            </SelectItem>
                            <SelectItem value="pt-BR">
                              <Text>Portuguese (Brazil)</Text>
                            </SelectItem>
                            <SelectItem value="ja-JP">
                              <Text>Japanese</Text>
                            </SelectItem>
                            <SelectItem value="ko-KR">
                              <Text>Korean</Text>
                            </SelectItem>
                            <SelectItem value="zh-CN">
                              <Text>Chinese (Simplified)</Text>
                            </SelectItem>
                          </SelectContent>
                        </Select>
                      </YStack>

                      <YStack>
                        <Label>
                          {t('chat.maxDuration')}: {settings.maxDuration / 1000}s
                        </Label>
                        <Slider
                          value={[settings.maxDuration / 1000]}
                          onValueChange={([value]) => handleSettingsChange({ maxDuration: value * 1000 })}
                          min={5}
                          max={120}
                          step={5}
                          marginTop="$2"
                        />
                      </YStack>

                      <YStack space="$3">
                        <XStack alignItems="center" justifyContent="space-between">
                          <Label>{t('chat.continuousMode')}</Label>
                          <Switch
                            checked={settings.continuous}
                            onCheckedChange={(checked) => handleSettingsChange({ continuous: checked })}
                          />
                        </XStack>

                        <XStack alignItems="center" justifyContent="space-between">
                          <Label>{t('chat.interimResults')}</Label>
                          <Switch
                            checked={settings.interimResults}
                            onCheckedChange={(checked) => handleSettingsChange({ interimResults: checked })}
                          />
                        </XStack>

                        <XStack alignItems="center" justifyContent="space-between">
                          <Label>{t('chat.noiseReduction')}</Label>
                          <Switch
                            checked={settings.noiseReduction}
                            onCheckedChange={(checked) => handleSettingsChange({ noiseReduction: checked })}
                          />
                        </XStack>

                        <XStack alignItems="center" justifyContent="space-between">
                          <Label>{t('chat.autoPunctuation')}</Label>
                          <Switch
                            checked={settings.autoPunctuation}
                            onCheckedChange={(checked) => handleSettingsChange({ autoPunctuation: checked })}
                          />
                        </XStack>
                      </YStack>
                    </YStack>
                  </DialogContent>
                </Dialog>
              )}
            </XStack>
          </CardContent>
        </Card>

        {/* Transcript Display */}
        {(transcript || interimTranscript) && (
          <Card bordered>
            <CardContent padding="$4">
              <YStack space="$2">
                <Text fontWeight="$6" fontSize="$3">{t('chat.transcript')}</Text>
                <YStack>
                  {transcript && (
                    <Text>{transcript}</Text>
                  )}
                  {interimTranscript && (
                    <Text color="$colorFocus" fontStyle="italic">{interimTranscript}</Text>
                  )}
                </YStack>
              </YStack>
            </CardContent>
          </Card>
        )}

        {/* Error Display */}
        {error && (
          <Card borderColor="$red8">
            <CardContent padding="$4">
              <XStack alignItems="center" gap="$2">
                <AlertCircle size={16} color="$red10" />
                <Text color="$red10" fontSize="$2">{error}</Text>
                <Button
                  chromeless
                  size="$1"
                  circular
                  marginLeft="auto"
                  onPress={() => setError(null)}
                >
                  <X size={12} />
                </Button>
              </XStack>
            </CardContent>
          </Card>
        )}
      </YStack>
    </Theme>
  );
}
