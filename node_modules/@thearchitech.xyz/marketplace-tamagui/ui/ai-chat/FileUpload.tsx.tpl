'use client';

import React, { useState, useRef, useCallback } from 'react';
import { 
  YStack, 
  XStack, 
  Button, 
  Text,
  Card,
  CardContent,
  Progress,
  Badge,
  Theme,
  Square,
  Input
} from 'tamagui';
import { 
  Paperclip, 
  File, 
  X, 
  Upload, 
  Check, 
  AlertCircle,
  Image as ImageIcon,
  FileText,
  Film,
  Music,
  Code,
  Archive,
  FileQuestion
} from 'lucide-react-native';
import { useTranslation } from '@/lib/i18n';

export interface FileUploadProps {
  onFileSelect?: (files: File[]) => void;
  onFileRemove?: (file: File) => void;
  onFileUpload?: (files: File[]) => Promise<string[]>;
  onError?: (error: Error) => void;
  maxFiles?: number;
  maxFileSize?: number; // in bytes
  acceptedFileTypes?: string[];
  className?: string;
  disabled?: boolean;
  showPreview?: boolean;
  showFileList?: boolean;
  showProgress?: boolean;
  allowMultiple?: boolean;
  compact?: boolean;
}

export function FileUpload({
  onFileSelect,
  onFileRemove,
  onFileUpload,
  onError,
  maxFiles = 5,
  maxFileSize = 10 * 1024 * 1024, // 10MB
  acceptedFileTypes = ['image/*', 'application/pdf', '.doc', '.docx', '.txt'],
  className,
  disabled = false,
  showPreview = true,
  showFileList = true,
  showProgress = true,
  allowMultiple = true,
  compact = false,
}: FileUploadProps) {
  const { t } = useTranslation();
  const [files, setFiles] = useState<File[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Handle file selection
  const handleFileSelect = useCallback((selectedFiles: FileList | null) => {
    if (!selectedFiles) return;
    
    setError(null);
    
    // Convert FileList to array
    const fileArray = Array.from(selectedFiles);
    
    // Check if max files would be exceeded
    if (files.length + fileArray.length > maxFiles) {
      setError(t('common.fileUpload.errors.tooManyFiles', { max: maxFiles }));
      return;
    }
    
    // Validate files
    const validFiles = fileArray.filter(file => {
      // Check file size
      if (file.size > maxFileSize) {
        setError(t('common.fileUpload.errors.fileTooLarge', { 
          filename: file.name,
          maxSize: formatFileSize(maxFileSize)
        }));
        return false;
      }
      
      // Check file type
      if (acceptedFileTypes.length > 0) {
        const fileType = file.type;
        const fileExtension = `.${file.name.split('.').pop()}`;
        
        const isAccepted = acceptedFileTypes.some(type => {
          if (type.includes('*')) {
            // Handle wildcards like 'image/*'
            return fileType.startsWith(type.split('/')[0]);
          }
          return type === fileType || type === fileExtension;
        });
        
        if (!isAccepted) {
          setError(t('common.fileUpload.errors.invalidFileType', { filename: file.name }));
          return false;
        }
      }
      
      return true;
    });
    
    if (validFiles.length > 0) {
      const newFiles = [...files, ...validFiles];
      setFiles(newFiles);
      onFileSelect?.(newFiles);
    }
  }, [files, maxFiles, maxFileSize, acceptedFileTypes, onFileSelect, t]);

  // Handle file removal
  const handleFileRemove = useCallback((fileToRemove: File) => {
    const newFiles = files.filter(file => file !== fileToRemove);
    setFiles(newFiles);
    onFileRemove?.(fileToRemove);
  }, [files, onFileRemove]);

  // Handle file upload
  const handleUpload = useCallback(async () => {
    if (!onFileUpload || files.length === 0) return;
    
    setIsUploading(true);
    setUploadProgress(0);
    setError(null);
    
    try {
      // Simulate upload progress
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => {
          const newProgress = prev + Math.random() * 15;
          return newProgress >= 100 ? 99 : newProgress;
        });
      }, 200);
      
      // Actual upload
      const urls = await onFileUpload(files);
      
      clearInterval(progressInterval);
      setUploadProgress(100);
      
      // Reset after upload
      setTimeout(() => {
        setIsUploading(false);
        setUploadProgress(0);
        setFiles([]);
      }, 1000);
      
      return urls;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : t('common.fileUpload.errors.uploadFailed');
      setError(errorMessage);
      onError?.(new Error(errorMessage));
    } finally {
      setIsUploading(false);
    }
  }, [files, onFileUpload, onError, t]);

  // Handle drag events
  const handleDrag = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  }, []);

  // Handle drop event
  const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileSelect(e.dataTransfer.files);
    }
  }, [handleFileSelect]);

  // Format file size
  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
  };

  // Get file icon based on type
  const getFileIcon = (file: File) => {
    const type = file.type;
    
    if (type.startsWith('image/')) {
      return <ImageIcon size={16} />;
    } else if (type.startsWith('video/')) {
      return <Film size={16} />;
    } else if (type.startsWith('audio/')) {
      return <Music size={16} />;
    } else if (type.startsWith('text/')) {
      return <FileText size={16} />;
    } else if (type.includes('pdf')) {
      return <FileText size={16} />;
    } else if (type.includes('zip') || type.includes('rar') || type.includes('tar')) {
      return <Archive size={16} />;
    } else if (type.includes('code') || type.includes('json') || type.includes('xml')) {
      return <Code size={16} />;
    }
    
    return <FileQuestion size={16} />;
  };

  return (
    <YStack {...(className ? { className } : {})}>
      {/* Drop Zone */}
      <YStack
        onDragEnter={handleDrag}
        borderWidth={1}
        borderColor={dragActive ? "$blue8" : "$borderColor"}
        borderStyle="dashed"
        borderRadius="$4"
        padding={compact ? "$3" : "$6"}
        alignItems="center"
        justifyContent="center"
        backgroundColor={dragActive ? "$blue2" : "transparent"}
        opacity={disabled ? 0.5 : 1}
        pointerEvents={disabled ? "none" : "auto"}
        animation="quick"
      >
        <Input
          ref={fileInputRef}
          type="file"
          multiple={allowMultiple}
          accept={acceptedFileTypes.join(',')}
          onChange={(e) => handleFileSelect(e.target.files)}
          display="none"
        />
        
        <YStack
          onDragOver={handleDrag}
          onDragLeave={handleDrag}
          onDrop={handleDrop}
          alignItems="center"
          justifyContent="center"
          space="$3"
          padding={compact ? "$2" : "$4"}
        >
          <Paperclip size={compact ? 20 : 32} opacity={0.7} />
          
          {!compact && (
            <>
              <Text fontSize="$3" fontWeight="$5" textAlign="center">
                {t('common.fileUpload.dragAndDrop')}
              </Text>
              <Text fontSize="$2" color="$gray11" textAlign="center">
                {t('common.fileUpload.or')}
              </Text>
            </>
          )}
          
          <Button
            onPress={() => fileInputRef.current?.click()}
            theme="accent"
            size={compact ? "$2" : "$3"}
          >
            {t('common.fileUpload.browseFiles')}
          </Button>
          
          {!compact && (
            <Text fontSize="$1" color="$gray10" textAlign="center">
              {t('common.fileUpload.maxFileSize', { size: formatFileSize(maxFileSize) })}
            </Text>
          )}
        </YStack>
      </YStack>
      
      {/* Error Message */}
      {error && (
        <Card marginTop="$2" borderColor="$red8">
          <CardContent padding="$3">
            <XStack alignItems="center" gap="$2">
              <AlertCircle size={16} color="$red10" />
              <Text fontSize="$2" color="$red10" flex={1}>
                {error}
              </Text>
              <Button
                chromeless
                circular
                size="$1"
                onPress={() => setError(null)}
              >
                <X size={12} />
              </Button>
            </XStack>
          </CardContent>
        </Card>
      )}
      
      {/* File List */}
      {showFileList && files.length > 0 && (
        <YStack marginTop="$3" space="$2">
          <Text fontSize="$2" fontWeight="$5">
            {t('common.fileUpload.selectedFiles')} ({files.length}/{maxFiles})
          </Text>
          
          <YStack space="$2">
            {files.map((file, index) => (
              <Card key={`${file.name}-${index}`} bordered>
                <CardContent padding="$3">
                  <XStack alignItems="center" gap="$2">
                    {getFileIcon(file)}
                    
                    <YStack flex={1}>
                      <Text fontSize="$2" fontWeight="$5" numberOfLines={1} ellipsizeMode="middle">
                        {file.name}
                      </Text>
                      <Text fontSize="$1" color="$gray10">
                        {formatFileSize(file.size)}
                      </Text>
                    </YStack>
                    
                    <Button
                      chromeless
                      circular
                      size="$1"
                      onPress={() => handleFileRemove(file)}
                      disabled={isUploading}
                    >
                      <X size={16} />
                    </Button>
                  </XStack>
                </CardContent>
              </Card>
            ))}
          </YStack>
          
          {onFileUpload && (
            <YStack marginTop="$2">
              {showProgress && isUploading && (
                <YStack marginBottom="$3" space="$1">
                  <Progress value={uploadProgress} size="$1" />
                  <Text fontSize="$1" color="$gray10" alignSelf="flex-end">
                    {Math.round(uploadProgress)}%
                  </Text>
                </YStack>
              )}
              
              <Button
                onPress={handleUpload}
                disabled={isUploading || files.length === 0}
                theme="accent"
                icon={isUploading ? undefined : <Upload size={16} />}
              >
                {isUploading ? (
                  <Text>{t('common.fileUpload.uploading')}</Text>
                ) : (
                  <Text>{t('common.fileUpload.upload')}</Text>
                )}
              </Button>
            </YStack>
          )}
        </YStack>
      )}
    </YStack>
  );
}

export default FileUpload;

