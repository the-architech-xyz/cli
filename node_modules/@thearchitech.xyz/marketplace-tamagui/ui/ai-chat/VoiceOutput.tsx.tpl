'use client';

import React, { useState, useCallback, useEffect, useRef } from 'react';
import { 
  YStack, 
  XStack, 
  Button, 
  Text,
  Card,
  CardContent,
  Badge,
  Progress,
  Slider,
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  Label,
  Switch,
  Theme,
  Square
} from 'tamagui';
import { 
  Play, 
  Pause, 
  Square as SquareIcon, 
  Volume2, 
  VolumeX, 
  Settings,
  CheckCircle,
  AlertCircle,
  Info,
  X,
  Zap,
  Clock,
  Waveform,
  SkipBack,
  SkipForward,
  RotateCcw
} from 'lucide-react-native';
import { useTranslation } from '@/lib/i18n';

export interface VoiceOutputProps {
  className?: string;
  text: string;
  onPlay?: () => void;
  onPause?: () => void;
  onStop?: () => void;
  onComplete?: () => void;
  onError?: (error: Error) => void;
  disabled?: boolean;
  autoPlay?: boolean;
  showControls?: boolean;
  showSettings?: boolean;
  showProgress?: boolean;
  showWaveform?: boolean;
}

export interface VoiceSettings {
  voice: string;
  rate: number;
  pitch: number;
  volume: number;
  language: string;
  autoPlay: boolean;
  highlightText: boolean;
  pauseOnHover: boolean;
  skipSilence: boolean;
  chunkSize: number;
}

export function VoiceOutput({
  className,
  text,
  onPlay,
  onPause,
  onStop,
  onComplete,
  onError,
  disabled = false,
  autoPlay = false,
  showControls = true,
  showSettings = true,
  showProgress = true,
  showWaveform = false,
}: VoiceOutputProps) {
  const { t } = useTranslation();
  const [isPlaying, setIsPlaying] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [isSupported, setIsSupported] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [currentText, setCurrentText] = useState('');
  const [highlightedText, setHighlightedText] = useState('');
  const [progress, setProgress] = useState(0);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);

  const utteranceRef = useRef<SpeechSynthesisUtterance | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const animationRef = useRef<number | null>(null);
  const progressIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const startTimeRef = useRef<number | null>(null);

  const [settings, setSettings] = useState<VoiceSettings>({
    voice: 'default',
    rate: 1,
    pitch: 1,
    volume: 1,
    language: 'en-US',
    autoPlay: false,
    highlightText: true,
    pauseOnHover: false,
    skipSilence: true,
    chunkSize: 200,
  });

  // Available voices
  const [voices, setVoices] = useState<SpeechSynthesisVoice[]>([]);

  // Check for speech synthesis support
  useEffect(() => {
    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
      setIsSupported(true);
      loadVoices();
    } else {
      setIsSupported(false);
      setError(t('ai.voice.notSupported'));
    }

    // Load voices when they become available
    const handleVoicesChanged = () => {
      loadVoices();
    };

    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
      window.speechSynthesis.addEventListener('voiceschanged', handleVoicesChanged);
    }

    return () => {
      if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
        window.speechSynthesis.removeEventListener('voiceschanged', handleVoicesChanged);
      }
      cleanup();
    };
  }, []);

  // Load available voices
  const loadVoices = useCallback(() => {
    if (typeof window === 'undefined' || !('speechSynthesis' in window)) return;
    
    const availableVoices = window.speechSynthesis.getVoices();
    setVoices(availableVoices);
    
    // Set default voice if not set
    if (settings.voice === 'default' && availableVoices.length > 0) {
      const defaultVoice = availableVoices.find(voice => 
        voice.lang.startsWith(settings.language)
      ) || availableVoices[0];
      
      setSettings(prev => ({ ...prev, voice: defaultVoice.name }));
    }
  }, [settings.language, settings.voice]);

  // Setup speech synthesis
  const setupSpeech = useCallback(() => {
    if (typeof window === 'undefined' || !('speechSynthesis' in window) || !text.trim()) return;

    // Cancel any existing speech
    window.speechSynthesis.cancel();

    const utterance = new SpeechSynthesisUtterance(text);
    utteranceRef.current = utterance;

    // Set voice
    const selectedVoice = voices.find(voice => voice.name === settings.voice);
    if (selectedVoice) {
      utterance.voice = selectedVoice;
    }

    // Set properties
    utterance.rate = settings.rate;
    utterance.pitch = settings.pitch;
    utterance.volume = settings.volume;
    utterance.lang = settings.language;

    // Event handlers
    utterance.onstart = () => {
      setIsPlaying(true);
      setIsPaused(false);
      setError(null);
      onPlay?.();
      startTimeRef.current = Date.now();
      startProgressTimer();
    };

    utterance.onend = () => {
      setIsPlaying(false);
      setIsPaused(false);
      setProgress(100);
      setCurrentTime(duration);
      onComplete?.();
      stopProgressTimer();
    };

    utterance.onerror = (event) => {
      const errorMessage = getErrorMessage(event.error);
      setError(errorMessage);
      setIsPlaying(false);
      setIsPaused(false);
      onError?.(new Error(errorMessage));
      stopProgressTimer();
    };

    utterance.onpause = () => {
      setIsPaused(true);
      onPause?.();
    };

    utterance.onresume = () => {
      setIsPaused(false);
      onPlay?.();
    };

    // Calculate estimated duration
    const estimatedDuration = (text.length / 200) * 1000; // Rough estimate
    setDuration(estimatedDuration);

    return utterance;
  }, [text, voices, settings, onPlay, onPause, onComplete, onError]);

  // Start progress timer
  const startProgressTimer = useCallback(() => {
    progressIntervalRef.current = setInterval(() => {
      if (startTimeRef.current) {
        const elapsed = Date.now() - startTimeRef.current;
        const progressPercent = Math.min((elapsed / duration) * 100, 100);
        setProgress(progressPercent);
        setCurrentTime(elapsed);
      }
    }, 100);
  }, [duration]);

  // Stop progress timer
  const stopProgressTimer = useCallback(() => {
    if (progressIntervalRef.current) {
      clearInterval(progressIntervalRef.current);
      progressIntervalRef.current = null;
    }
  }, []);

  // Get error message
  const getErrorMessage = (error: string): string => {
    switch (error) {
      case 'network':
        return t('ai.voice.errors.network');
      case 'synthesis-failed':
        return t('ai.voice.errors.synthesisFailed');
      case 'synthesis-unavailable':
        return t('ai.voice.errors.synthesisUnavailable');
      case 'language-unavailable':
        return t('ai.voice.errors.languageUnavailable');
      case 'voice-unavailable':
        return t('ai.voice.errors.voiceUnavailable');
      case 'text-too-long':
        return t('ai.voice.errors.textTooLong');
      case 'invalid-argument':
        return t('ai.voice.errors.invalidArgument');
      default:
        return t('ai.voice.errors.generic', { error });
    }
  };

  // Play speech
  const playSpeech = useCallback(() => {
    if (isPlaying || disabled || typeof window === 'undefined' || !('speechSynthesis' in window)) return;

    try {
      setError(null);
      setIsProcessing(true);
      
      const utterance = setupSpeech();
      if (utterance) {
        window.speechSynthesis.speak(utterance);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : t('ai.voice.errors.failedToStart');
      setError(errorMessage);
      onError?.(new Error(errorMessage));
    } finally {
      setIsProcessing(false);
    }
  }, [isPlaying, disabled, setupSpeech, onError, t]);

  // Pause speech
  const pauseSpeech = useCallback(() => {
    if (typeof window === 'undefined' || !('speechSynthesis' in window)) return;
    if (isPlaying && !isPaused) {
      window.speechSynthesis.pause();
    }
  }, [isPlaying, isPaused]);

  // Resume speech
  const resumeSpeech = useCallback(() => {
    if (typeof window === 'undefined' || !('speechSynthesis' in window)) return;
    if (isPaused) {
      window.speechSynthesis.resume();
    }
  }, [isPaused]);

  // Stop speech
  const stopSpeech = useCallback(() => {
    if (typeof window === 'undefined' || !('speechSynthesis' in window)) return;
    window.speechSynthesis.cancel();
    setIsPlaying(false);
    setIsPaused(false);
    setProgress(0);
    setCurrentTime(0);
    onStop?.();
    stopProgressTimer();
  }, [onStop, stopProgressTimer]);

  // Toggle play/pause
  const togglePlayPause = useCallback(() => {
    if (isPlaying) {
      if (isPaused) {
        resumeSpeech();
      } else {
        pauseSpeech();
      }
    } else {
      playSpeech();
    }
  }, [isPlaying, isPaused, playSpeech, pauseSpeech, resumeSpeech]);

  // Handle settings change
  const handleSettingsChange = useCallback((updates: Partial<VoiceSettings>) => {
    setSettings(prev => ({ ...prev, ...updates }));
  }, []);

  // Format time
  const formatTime = (ms: number): string => {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Cleanup
  const cleanup = useCallback(() => {
    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
      window.speechSynthesis.cancel();
    }
    stopProgressTimer();
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, [stopProgressTimer]);

  // Auto-play effect
  useEffect(() => {
    if (autoPlay && isSupported && !disabled && text.trim()) {
      playSpeech();
    }
  }, [autoPlay, isSupported, disabled, text, playSpeech]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);

  if (!isSupported) {
    return (
      <YStack padding="$4" {...(className ? { className } : {})}>
        <Card width="100%" maxWidth={400} alignSelf="center">
          <CardContent padding="$6" alignItems="center">
            <AlertCircle color="$red10" size={32} marginBottom="$2" />
            <Text fontWeight="$6" marginBottom="$2">
              {t('ai.voice.notSupportedTitle')}
            </Text>
            <Text fontSize="$2" color="$gray10" textAlign="center">
              {t('ai.voice.notSupportedDescription')}
            </Text>
          </CardContent>
        </Card>
      </YStack>
    );
  }

  return (
    <YStack space="$4" {...(className ? { className } : {})}>
      {/* Main Voice Output */}
      <Card>
        <CardContent padding="$4">
          <YStack space="$4">
            {/* Text Display */}
            <YStack space="$2">
              <Text fontWeight="$5" fontSize="$2">
                {t('ai.voice.textToSpeech')}
              </Text>
              <YStack maxHeight={128} overflow="hidden" scrollable>
                <Text fontSize="$2" color="$gray11">
                  {text}
                </Text>
              </YStack>
            </YStack>

            {/* Controls */}
            {showControls && (
              <XStack alignItems="center" gap="$2">
                <Button
                  size="$4"
                  circular
                  theme={isPlaying ? "accent" : undefined}
                  onPress={togglePlayPause}
                  disabled={disabled || !text.trim()}
                  opacity={isPlaying && !isPaused ? 0.8 : 1}
                  animation="quick"
                  pressStyle={{ scale: 0.95 }}
                >
                  {isPlaying ? (
                    isPaused ? <Play size={16} /> : <Pause size={16} />
                  ) : (
                    <Play size={16} />
                  )}
                </Button>

                <Button
                  chromeless
                  bordered
                  size="$2"
                  onPress={stopSpeech}
                  disabled={!isPlaying && !isPaused}
                >
                  <SquareIcon size={16} />
                </Button>

                <Button
                  chromeless
                  bordered
                  size="$2"
                  onPress={() => {
                    setCurrentText('');
                    setHighlightedText('');
                    setProgress(0);
                    setCurrentTime(0);
                  }}
                >
                  <RotateCcw size={16} />
                </Button>

                {/* Status */}
                <XStack marginLeft="auto" alignItems="center" gap="$2">
                  <Badge theme={isPlaying ? "accent" : undefined}>
                    {isPlaying ? (isPaused ? t('ai.voice.paused') : t('ai.voice.playing')) : t('ai.voice.ready')}
                  </Badge>
                  {isPlaying && (
                    <Badge variant="outline">
                      {formatTime(currentTime)} / {formatTime(duration)}
                    </Badge>
                  )}
                </XStack>

                {/* Settings */}
                {showSettings && (
                  <Dialog open={isSettingsOpen} onOpenChange={setIsSettingsOpen}>
                    <DialogTrigger asChild>
                      <Button chromeless bordered size="$2">
                        <Settings size={16} />
                      </Button>
                    </DialogTrigger>
                    <DialogContent>
                      <DialogHeader>
                        <DialogTitle>{t('ai.voice.settings')}</DialogTitle>
                      </DialogHeader>
                      <YStack space="$4" paddingVertical="$2">
                        <YStack>
                          <Label>{t('ai.voice.voice')}</Label>
                          <Select
                            value={settings.voice}
                            onValueChange={(value) => handleSettingsChange({ voice: value })}
                          >
                            <Select.Trigger width="100%" marginTop="$1">
                              <Select.Value placeholder={t('ai.voice.selectVoice')} />
                            </Select.Trigger>
                            <Select.Content>
                              <Select.ScrollUpButton />
                              <Select.Viewport>
                                <Select.Group>
                                  {voices.map((voice, index) => (
                                    <Select.Item key={index} value={voice.name}>
                                      <Select.ItemText>
                                        {voice.name} ({voice.lang})
                                      </Select.ItemText>
                                    </Select.Item>
                                  ))}
                                </Select.Group>
                              </Select.Viewport>
                              <Select.ScrollDownButton />
                            </Select.Content>
                          </Select>
                        </YStack>

                        <YStack>
                          <Label>{t('ai.voice.language')}</Label>
                          <Select
                            value={settings.language}
                            onValueChange={(value) => handleSettingsChange({ language: value })}
                          >
                            <Select.Trigger width="100%" marginTop="$1">
                              <Select.Value placeholder={t('ai.voice.selectLanguage')} />
                            </Select.Trigger>
                            <Select.Content>
                              <Select.ScrollUpButton />
                              <Select.Viewport>
                                <Select.Group>
                                  <Select.Item value="en-US">
                                    <Select.ItemText>English (US)</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="en-GB">
                                    <Select.ItemText>English (UK)</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="es-ES">
                                    <Select.ItemText>Spanish</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="fr-FR">
                                    <Select.ItemText>French</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="de-DE">
                                    <Select.ItemText>German</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="it-IT">
                                    <Select.ItemText>Italian</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="pt-BR">
                                    <Select.ItemText>Portuguese (Brazil)</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="ja-JP">
                                    <Select.ItemText>Japanese</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="ko-KR">
                                    <Select.ItemText>Korean</Select.ItemText>
                                  </Select.Item>
                                  <Select.Item value="zh-CN">
                                    <Select.ItemText>Chinese (Simplified)</Select.ItemText>
                                  </Select.Item>
                                </Select.Group>
                              </Select.Viewport>
                              <Select.ScrollDownButton />
                            </Select.Content>
                          </Select>
                        </YStack>

                        <YStack>
                          <Label>{t('ai.voice.rate', { rate: settings.rate })}</Label>
                          <Slider
                            value={[settings.rate]}
                            onValueChange={([value]) => handleSettingsChange({ rate: value })}
                            min={0.5}
                            max={2}
                            step={0.1}
                            marginTop="$2"
                          >
                            <Slider.Track>
                              <Slider.TrackActive />
                            </Slider.Track>
                            <Slider.Thumb circular index={0} />
                          </Slider>
                        </YStack>

                        <YStack>
                          <Label>{t('ai.voice.pitch', { pitch: settings.pitch })}</Label>
                          <Slider
                            value={[settings.pitch]}
                            onValueChange={([value]) => handleSettingsChange({ pitch: value })}
                            min={0.5}
                            max={2}
                            step={0.1}
                            marginTop="$2"
                          >
                            <Slider.Track>
                              <Slider.TrackActive />
                            </Slider.Track>
                            <Slider.Thumb circular index={0} />
                          </Slider>
                        </YStack>

                        <YStack>
                          <Label>{t('ai.voice.volume', { volume: Math.round(settings.volume * 100) })}</Label>
                          <Slider
                            value={[settings.volume]}
                            onValueChange={([value]) => handleSettingsChange({ volume: value })}
                            min={0}
                            max={1}
                            step={0.1}
                            marginTop="$2"
                          >
                            <Slider.Track>
                              <Slider.TrackActive />
                            </Slider.Track>
                            <Slider.Thumb circular index={0} />
                          </Slider>
                        </YStack>

                        <YStack space="$3">
                          <XStack alignItems="center" justifyContent="space-between">
                            <Label>{t('ai.voice.autoPlay')}</Label>
                            <Switch
                              checked={settings.autoPlay}
                              onCheckedChange={(checked) => handleSettingsChange({ autoPlay: checked })}
                            />
                          </XStack>

                          <XStack alignItems="center" justifyContent="space-between">
                            <Label>{t('ai.voice.highlightText')}</Label>
                            <Switch
                              checked={settings.highlightText}
                              onCheckedChange={(checked) => handleSettingsChange({ highlightText: checked })}
                            />
                          </XStack>

                          <XStack alignItems="center" justifyContent="space-between">
                            <Label>{t('ai.voice.pauseOnHover')}</Label>
                            <Switch
                              checked={settings.pauseOnHover}
                              onCheckedChange={(checked) => handleSettingsChange({ pauseOnHover: checked })}
                            />
                          </XStack>
                        </YStack>
                      </YStack>
                    </DialogContent>
                  </Dialog>
                )}
              </XStack>
            )}

            {/* Progress Bar */}
            {showProgress && isPlaying && (
              <YStack space="$2">
                <Progress value={progress} size="$1" />
                <XStack justifyContent="space-between">
                  <Text fontSize="$1" color="$gray10">
                    {formatTime(currentTime)}
                  </Text>
                  <Text fontSize="$1" color="$gray10">
                    {formatTime(duration)}
                  </Text>
                </XStack>
              </YStack>
            )}
          </YStack>
        </CardContent>
      </Card>

      {/* Error Display */}
      {error && (
        <Card borderColor="$red8">
          <CardContent padding="$4">
            <XStack alignItems="center" gap="$2">
              <AlertCircle size={16} color="$red10" />
              <Text fontSize="$2" color="$red10" flex={1}>
                {error}
              </Text>
              <Button
                chromeless
                circular
                size="$1"
                onPress={() => setError(null)}
              >
                <X size={12} />
              </Button>
            </XStack>
          </CardContent>
        </Card>
      )}
    </YStack>
  );
}

export default VoiceOutput;

