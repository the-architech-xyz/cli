'use client';

import React, { useState, useCallback, useEffect } from 'react';
import { useTranslation } from '@/lib/i18n';
import { 
  AlertCircle, 
  X, 
  RotateCcw, 
  RefreshCw, 
  Info, 
  AlertTriangle,
  Bug,
  Wifi,
  Server,
  Shield,
  Clock,
  CheckCircle
} from 'lucide-react-native';

import {
  YStack,
  XStack,
  Button,
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  Badge,
  Text,
  Theme,
  Square,
  Spinner
} from 'tamagui';

// Define ChatError type if not imported
interface ChatError extends Error {
  type: string;
}

export interface ErrorDisplayProps {
  error: Error | ChatError;
  onRetry?: () => void;
  onDismiss?: () => void;
  onReport?: () => void;
  variant?: 'default' | 'minimal' | 'card' | 'inline' | 'toast' | 'modal';
  size?: 'sm' | 'md' | 'lg';
  showIcon?: boolean;
  showActions?: boolean;
  showDetails?: boolean;
  showReport?: boolean;
  showRetry?: boolean;
  showDismiss?: boolean;
  persistent?: boolean;
  autoDismiss?: boolean;
  autoDismissDelay?: number;
  onAutoDismiss?: () => void;
}

export function ErrorDisplay({
  error,
  onRetry,
  onDismiss,
  onReport,
  variant = 'default',
  size = 'md',
  showIcon = true,
  showActions = true,
  showDetails = false,
  showReport = false,
  showRetry = true,
  showDismiss = true,
  persistent = false,
  autoDismiss = false,
  autoDismissDelay = 5000,
  onAutoDismiss,
}: ErrorDisplayProps) {
  const { t } = useTranslation();
  const [isExpanded, setIsExpanded] = useState(false);
  const [isRetrying, setIsRetrying] = useState(false);

  // Get error type
  const getErrorType = (): string => {
    if ('type' in error) {
      return error.type;
    }
    if (error.message.includes('network') || error.message.includes('fetch')) {
      return 'network_error';
    }
    if (error.message.includes('permission') || error.message.includes('denied')) {
      return 'permission_error';
    }
    if (error.message.includes('timeout')) {
      return 'timeout_error';
    }
    if (error.message.includes('quota') || error.message.includes('limit')) {
      return 'quota_error';
    }
    if (error.message.includes('validation') || error.message.includes('invalid')) {
      return 'validation_error';
    }
    return 'unknown_error';
  };

  // Get error icon
  const getErrorIcon = () => {
    const errorType = getErrorType();
    switch (errorType) {
      case 'network_error':
        return <Wifi size={20} color="$blue10" />;
      case 'permission_error':
        return <Shield size={20} color="$yellow10" />;
      case 'timeout_error':
        return <Clock size={20} color="$orange10" />;
      case 'quota_error':
        return <AlertTriangle size={20} color="$red10" />;
      case 'validation_error':
        return <Info size={20} color="$purple10" />;
      case 'model_error':
        return <Server size={20} color="$blue10" />;
      case 'rate_limit_error':
        return <Clock size={20} color="$amber10" />;
      default:
        return <AlertCircle size={20} color="$red10" />;
    }
  };

  // Get error color theme
  const getErrorTheme = (): string => {
    const errorType = getErrorType();
    switch (errorType) {
      case 'network_error':
        return 'blue';
      case 'permission_error':
        return 'yellow';
      case 'timeout_error':
        return 'orange';
      case 'quota_error':
        return 'red';
      case 'validation_error':
        return 'purple';
      case 'model_error':
        return 'blue';
      case 'rate_limit_error':
        return 'yellow';
      default:
        return 'red';
    }
  };

  // Get error border color
  const getErrorBorderColor = (): string => {
    const errorType = getErrorType();
    switch (errorType) {
      case 'network_error':
        return '$blue8';
      case 'permission_error':
        return '$yellow8';
      case 'timeout_error':
        return '$orange8';
      case 'quota_error':
        return '$red8';
      case 'validation_error':
        return '$purple8';
      case 'model_error':
        return '$blue8';
      case 'rate_limit_error':
        return '$amber8';
      default:
        return '$red8';
    }
  };

  // Get error background color
  const getErrorBackgroundColor = (): string => {
    const errorType = getErrorType();
    switch (errorType) {
      case 'network_error':
        return '$blue2';
      case 'permission_error':
        return '$yellow2';
      case 'timeout_error':
        return '$orange2';
      case 'quota_error':
        return '$red2';
      case 'validation_error':
        return '$purple2';
      case 'model_error':
        return '$blue2';
      case 'rate_limit_error':
        return '$amber2';
      default:
        return '$red2';
    }
  };

  // Get error title
  const getErrorTitle = (): string => {
    const errorType = getErrorType();
    switch (errorType) {
      case 'network_error':
        return t('errors.connectionError');
      case 'permission_error':
        return t('errors.permissionDenied');
      case 'timeout_error':
        return t('errors.requestTimeout');
      case 'quota_error':
        return t('errors.quotaExceeded');
      case 'validation_error':
        return t('errors.invalidInput');
      case 'model_error':
        return t('errors.modelError');
      case 'rate_limit_error':
        return t('errors.rateLimited');
      default:
        return t('errors.generalError');
    }
  };

  // Get error description
  const getErrorDescription = (): string => {
    const errorType = getErrorType();
    switch (errorType) {
      case 'network_error':
        return t('errors.networkErrorDesc');
      case 'permission_error':
        return t('errors.permissionErrorDesc');
      case 'timeout_error':
        return t('errors.timeoutErrorDesc');
      case 'quota_error':
        return t('errors.quotaErrorDesc');
      case 'validation_error':
        return t('errors.validationErrorDesc');
      case 'model_error':
        return t('errors.modelErrorDesc');
      case 'rate_limit_error':
        return t('errors.rateLimitErrorDesc');
      default:
        return t('errors.generalErrorDesc');
    }
  };

  // Handle retry
  const handleRetry = useCallback(async () => {
    if (isRetrying) return;
    
    setIsRetrying(true);
    try {
      await onRetry?.();
    } finally {
      setIsRetrying(false);
    }
  }, [isRetrying, onRetry]);

  // Handle dismiss
  const handleDismiss = useCallback(() => {
    onDismiss?.();
  }, [onDismiss]);

  // Handle report
  const handleReport = useCallback(() => {
    onReport?.();
  }, [onReport]);

  // Auto dismiss effect
  useEffect(() => {
    if (autoDismiss && !persistent) {
      const timer = setTimeout(() => {
        onAutoDismiss?.();
      }, autoDismissDelay);
      return () => clearTimeout(timer);
    }
  }, [autoDismiss, persistent, autoDismissDelay, onAutoDismiss]);

  // Render content
  const renderContent = () => (
    <XStack alignItems="flex-start" gap="$3">
      {/* Icon */}
      {showIcon && (
        <YStack marginTop="$1" flexShrink={0}>
          {getErrorIcon()}
        </YStack>
      )}

      {/* Content */}
      <YStack flex={1} minWidth={0}>
        {/* Title and Message */}
        <YStack space="$1">
          <Text fontWeight="$6" fontSize="$3">
            {getErrorTitle()}
          </Text>
          <Text fontSize="$2" color="$colorFocus">
            {getErrorDescription()}
          </Text>
          {showDetails && (
            <YStack>
              <Button
                chromeless
                onPress={() => setIsExpanded(!isExpanded)}
                justifyContent="flex-start"
                paddingLeft={0}
                paddingRight={0}
              >
                <Text fontSize="$1" color="$colorFocus">
                  {t('common.technicalDetails')}
                </Text>
              </Button>
              {isExpanded && (
                <YStack
                  marginTop="$2"
                  padding="$2"
                  backgroundColor="$backgroundHover"
                  borderRadius="$2"
                >
                  <Text fontFamily="$mono" fontSize="$1" whiteSpace="pre-wrap">
                    {error.message}
                    {error.stack && `\n\nStack Trace:\n${error.stack}`}
                  </Text>
                </YStack>
              )}
            </YStack>
          )}
        </YStack>

        {/* Actions */}
        {showActions && (
          <XStack alignItems="center" gap="$2" marginTop="$3">
            {showRetry && onRetry && (
              <Button
                size="$2"
                variant="outlined"
                onPress={handleRetry}
                disabled={isRetrying}
              >
                <XStack alignItems="center" gap="$1">
                  {isRetrying ? (
                    <Spinner size="small" />
                  ) : (
                    <RotateCcw size={12} />
                  )}
                  <Text fontSize="$2">
                    {isRetrying ? t('common.retrying') : t('common.retry')}
                  </Text>
                </XStack>
              </Button>
            )}
            
            {showReport && onReport && (
              <Button
                size="$2"
                variant="outlined"
                onPress={handleReport}
              >
                <XStack alignItems="center" gap="$1">
                  <Bug size={12} />
                  <Text fontSize="$2">{t('common.report')}</Text>
                </XStack>
              </Button>
            )}
            
            {showDismiss && onDismiss && (
              <Button
                size="$2"
                chromeless
                onPress={handleDismiss}
              >
                <XStack alignItems="center" gap="$1">
                  <X size={12} />
                  <Text fontSize="$2">{t('common.dismiss')}</Text>
                </XStack>
              </Button>
            )}
          </XStack>
        )}
      </YStack>
    </XStack>
  );

  // Render based on variant
  if (variant === 'minimal') {
    return (
      <XStack 
        alignItems="center" 
        gap="$2" 
        backgroundColor={getErrorBackgroundColor()}
        paddingVertical="$1"
        paddingHorizontal="$2"
        borderRadius="$2"
      >
        {showIcon && getErrorIcon()}
        <Text fontSize="$2">{error.message}</Text>
        {showDismiss && onDismiss && (
          <Button
            size="$1"
            circular
            chromeless
            onPress={handleDismiss}
          >
            <X size={12} />
          </Button>
        )}
      </XStack>
    );
  }

  if (variant === 'inline') {
    return (
      <XStack 
        alignItems="center" 
        gap="$1"
        display="inline-flex"
      >
        {showIcon && getErrorIcon()}
        <Text fontSize="$1">{error.message}</Text>
      </XStack>
    );
  }

  if (variant === 'toast') {
    return (
      <YStack
        position="fixed"
        top={16}
        right={16}
        zIndex={50}
        maxWidth={320}
      >
        <Card
          bordered
          elevate
          borderLeftWidth={4}
          borderLeftColor={getErrorBorderColor()}
          animation="bouncy"
          scale={1}
          hoverStyle={{ scale: 1.02 }}
          pressStyle={{ scale: 0.98 }}
        >
          <CardContent padding="$3">
            {renderContent()}
          </CardContent>
        </Card>
      </YStack>
    );
  }

  if (variant === 'modal') {
    return (
      <YStack
        position="fixed"
        inset={0}
        backgroundColor="$backgroundTransparent"
        backdropFilter="blur(4px)"
        alignItems="center"
        justifyContent="center"
        zIndex={50}
        padding="$4"
      >
        <Card
          width="100%"
          maxWidth={400}
          bordered
          elevate
        >
          <CardHeader>
            <CardTitle>
              <XStack alignItems="center" gap="$2">
                {showIcon && getErrorIcon()}
                <Text fontWeight="$7" fontSize="$5">{getErrorTitle()}</Text>
              </XStack>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <YStack space="$4">
              <Text fontSize="$3" color="$colorFocus">
                {getErrorDescription()}
              </Text>
              {showActions && (
                <XStack justifyContent="flex-end" gap="$2">
                  {showRetry && onRetry && (
                    <Button
                      variant="outlined"
                      onPress={handleRetry}
                      disabled={isRetrying}
                    >
                      {isRetrying ? t('common.retrying') : t('common.retry')}
                    </Button>
                  )}
                  {showDismiss && onDismiss && (
                    <Button onPress={handleDismiss}>
                      {t('common.dismiss')}
                    </Button>
                  )}
                </XStack>
              )}
            </YStack>
          </CardContent>
        </Card>
      </YStack>
    );
  }

  // Default variant (card)
  return (
    <Card
      bordered
      borderLeftWidth={4}
      borderLeftColor={getErrorBorderColor()}
      backgroundColor={getErrorBackgroundColor()}
    >
      <CardContent padding="$4">
        {renderContent()}
      </CardContent>
    </Card>
  );
}
