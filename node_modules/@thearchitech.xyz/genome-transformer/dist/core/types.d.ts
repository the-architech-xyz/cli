/**
 * Core Types for Genome Transformation Engine
 */
import { Genome, Module, ModuleTemplate } from '@thearchitech.xyz/types';
import type { ResolvedGenome } from '@thearchitech.xyz/types';
export type { Module, ModuleTemplate };
export interface TransformationConfig {
    marketplacePath: string;
    logger: Logger;
    manifestPath?: string;
    capabilityManifestPath?: string;
    options?: {
        enableCapabilityResolution?: boolean;
        enableAutoInclusion?: boolean;
        enableParameterDistribution?: boolean;
        enableConnectorAutoInclusion?: boolean;
    };
}
export interface TransformationContext {
    marketplacePath: string;
    logger: Logger;
    config: TransformationConfig;
    metadata: Record<string, any>;
}
export interface TransformationStep {
    transformer: string;
    duration: number;
    modulesCount: number;
    success: boolean;
    error?: string;
}
export interface TransformationResult {
    originalGenome: Genome;
    resolvedGenome: ResolvedGenome;
    transformationSteps: TransformationStep[];
    success: boolean;
    error?: string;
    duration: number;
}
export interface GenomeTransformer {
    readonly name: string;
    readonly priority: number;
    readonly description: string;
    transform(genome: ProcessedGenome, context: TransformationContext): Promise<ProcessedGenome>;
    canTransform(genome: ProcessedGenome): boolean;
    validate(genome: ProcessedGenome): Promise<ValidationResult>;
}
export interface ValidationResult {
    valid: boolean;
    errors: string[];
    warnings: string[];
}
export interface Logger {
    info(message: string, meta?: any): void;
    debug(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, meta?: any): void;
}
export interface CapabilityGenome extends Genome {
    capabilities?: Record<string, CapabilityConfig>;
}
/**
 * Capability Configuration (New Structure)
 *
 * Represents a capability-driven configuration with layer-separated parameters.
 * This matches the new capability-first genome structure from the marketplace.
 */
export interface CapabilityConfig {
    /**
     * Provider name (framework-agnostic, e.g., 'better-auth', not 'better-auth-nextjs')
     * Required for provider-based capabilities, optional for UI-only capabilities
     */
    provider?: string;
    /**
     * Provider-specific adapter parameters (from adapter.json)
     * These parameters are specific to the chosen provider and are passed directly to the adapter module
     */
    adapter?: Record<string, any>;
    /**
     * UI-agnostic frontend parameters
     * Only includes UI-agnostic parameters (no theme, tokens, or UI-specific configs)
     */
    frontend?: {
        features?: Record<string, boolean | any>;
        [key: string]: any;
    };
    /**
     * Standardized tech-stack parameters
     * Same structure for all capabilities (hasTypes, hasSchemas, hasHooks, etc.)
     */
    techStack?: {
        hasTypes?: boolean;
        hasSchemas?: boolean;
        hasHooks?: boolean;
        hasStores?: boolean;
        hasApiRoutes?: boolean;
        hasValidation?: boolean;
        [key: string]: any;
    };
    /**
     * Shared parameters (applied to all layers: adapter, frontend, tech-stack, backend, database)
     * Use this for parameters that should be inherited across all layers of the capability
     */
    shared?: Record<string, any>;
    /**
     * Backend parameters (only if explicitly configured)
     * Backend layer is not included by default, only if explicitly specified
     */
    backend?: Record<string, any>;
    /**
     * Database parameters (only if explicitly configured)
     * Database layer is not included by default, only if explicitly specified
     */
    database?: Record<string, any>;
    /** @deprecated Use layer-specific parameters (adapter, frontend, techStack, backend, database) instead */
    features?: string[];
    /** @deprecated Frontend layer is always included, use frontend.features instead */
    parameters?: Record<string, any>;
}
export interface TRPCDetectionResult {
    enabled: boolean;
    features: string[];
    routerPath?: string;
}
export interface UIMarketplaceResult {
    framework: string;
    components: Record<string, string>;
    manifest: any;
}
export interface ProcessedGenome {
    version: string;
    project: any;
    modules: Module[];
    capabilities?: Record<string, CapabilityConfig>;
    features?: string[];
    options?: any;
    metadata?: Record<string, any>;
}
export interface ExtendedModule extends Module {
    uiComponents?: string[];
}
//# sourceMappingURL=types.d.ts.map