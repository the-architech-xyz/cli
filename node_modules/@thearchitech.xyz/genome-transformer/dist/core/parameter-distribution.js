/**
 * Parameter Distribution System
 *
 * Handles parameter inheritance and distribution from capabilities to modules
 * with validation to ensure modules can handle the parameters being distributed.
 */
export class ParameterDistributionService {
    logger;
    moduleSchemas = new Map();
    distributionRules = [];
    constructor(logger) {
        this.logger = logger;
        this.initializeDistributionRules();
    }
    /**
     * Initialize parameter distribution rules for each capability
     *
     * Uses new nested path structure:
     * - adapter.* -> adapter module parameters
     * - frontend.features.* -> frontend module parameters
     * - techStack.* -> tech-stack module parameters
     * - shared.* -> all layers (adapter, frontend, tech-stack)
     */
    initializeDistributionRules() {
        // ============================================================================
        // AUTH CAPABILITY RULES
        // ============================================================================
        // Adapter parameters (direct inheritance from adapter.*)
        this.distributionRules.push({
            capability: 'auth',
            sourcePath: 'adapter.oauthProviders',
            targetModule: 'adapters/auth/better-auth',
            targetParameter: 'oauthProviders',
            validation: (value) => Array.isArray(value) && value.every(p => typeof p === 'string')
        }, {
            capability: 'auth',
            sourcePath: 'adapter.twoFactor',
            targetModule: 'adapters/auth/better-auth',
            targetParameter: 'twoFactor',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'adapter.organizations',
            targetModule: 'adapters/auth/better-auth',
            targetParameter: 'organizations',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'adapter.sessionExpiry',
            targetModule: 'adapters/auth/better-auth',
            targetParameter: 'sessionExpiry',
            validation: (value) => typeof value === 'number' && value > 0
        }, {
            capability: 'auth',
            sourcePath: 'adapter.emailPassword',
            targetModule: 'adapters/auth/better-auth',
            targetParameter: 'emailPassword',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'adapter.emailVerification',
            targetModule: 'adapters/auth/better-auth',
            targetParameter: 'emailVerification',
            validation: (value) => typeof value === 'boolean'
        }, 
        // Frontend parameters (from frontend.features.*)
        {
            capability: 'auth',
            sourcePath: 'frontend.features.signIn',
            targetModule: 'features/auth/frontend',
            targetParameter: 'features.signIn',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'frontend.features.signUp',
            targetModule: 'features/auth/frontend',
            targetParameter: 'features.signUp',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'frontend.features.twoFactor',
            targetModule: 'features/auth/frontend',
            targetParameter: 'features.twoFactor',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'frontend.features.organizationManagement',
            targetModule: 'features/auth/frontend',
            targetParameter: 'features.organizationManagement',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'adapter.oauthProviders',
            targetModule: 'features/auth/frontend',
            targetParameter: 'features.socialLogins',
            transformation: (providers) => providers && Array.isArray(providers) && providers.length > 0,
            validation: (value) => typeof value === 'boolean'
        }, 
        // Tech-stack parameters (from techStack.*)
        {
            capability: 'auth',
            sourcePath: 'techStack.hasTypes',
            targetModule: 'features/auth/tech-stack',
            targetParameter: 'hasTypes',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'techStack.hasSchemas',
            targetModule: 'features/auth/tech-stack',
            targetParameter: 'hasSchemas',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'techStack.hasHooks',
            targetModule: 'features/auth/tech-stack',
            targetParameter: 'hasHooks',
            validation: (value) => typeof value === 'boolean'
        }, {
            capability: 'auth',
            sourcePath: 'techStack.hasStores',
            targetModule: 'features/auth/tech-stack',
            targetParameter: 'hasStores',
            validation: (value) => typeof value === 'boolean'
        }, 
        // Shared parameters (apply to all layers)
        {
            capability: 'auth',
            sourcePath: 'shared.emailVerification',
            targetModule: [
                'adapters/auth/better-auth',
                'features/auth/frontend',
                'features/auth/tech-stack'
            ],
            targetParameter: 'emailVerification',
            validation: (value) => typeof value === 'boolean'
        });
        // TODO: Add rules for other capabilities (payments, emailing, etc.)
        // Rules can be dynamically generated or added as needed
        // Add more capability rules here as needed
        // Payments, emailing, etc.
    }
    /**
     * Load module parameter schemas from marketplace
     */
    async loadModuleSchemas(marketplacePath) {
        this.logger.info('ðŸ” Loading module parameter schemas...', {
            operation: 'parameter_distribution'
        });
        try {
            const fs = await import('fs/promises');
            const path = await import('path');
            // Load adapter schemas
            await this.loadSchemasFromDirectory(path.join(marketplacePath, 'adapters'), 'adapter.json', fs, path);
            // Load feature schemas
            await this.loadSchemasFromDirectory(path.join(marketplacePath, 'features'), 'feature.json', fs, path);
            // Load connector schemas
            await this.loadSchemasFromDirectory(path.join(marketplacePath, 'connectors'), 'connector.json', fs, path);
            this.logger.info(`âœ… Loaded ${this.moduleSchemas.size} module schemas`, {
                operation: 'parameter_distribution'
            });
        }
        catch (error) {
            this.logger.error('âŒ Failed to load module schemas', {
                operation: 'parameter_distribution',
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }
    /**
     * Load schemas from a directory recursively
     */
    async loadSchemasFromDirectory(dirPath, schemaFileName, fs, path) {
        try {
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dirPath, entry.name);
                if (entry.isDirectory()) {
                    await this.loadSchemasFromDirectory(fullPath, schemaFileName, fs, path);
                }
                else if (entry.name === schemaFileName) {
                    await this.loadSchemaFromFile(fullPath, fs);
                }
            }
        }
        catch (error) {
            // Directory might not exist, skip silently
        }
    }
    /**
     * Load schema from a single file
     */
    async loadSchemaFromFile(filePath, fs) {
        try {
            const content = await fs.readFile(filePath, 'utf8');
            const schema = JSON.parse(content);
            if (schema.id && schema.parameters) {
                this.moduleSchemas.set(schema.id, schema.parameters);
            }
        }
        catch (error) {
            this.logger.warn(`âš ï¸ Failed to load schema from ${filePath}`, {
                operation: 'parameter_distribution',
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }
    /**
     * Distribute capability parameters to modules
     */
    async distributeParameters(genome, marketplacePath) {
        this.logger.info('ðŸ”„ Distributing capability parameters to modules...', {
            operation: 'parameter_distribution',
            capabilities: Object.keys(genome.capabilities || {}).length,
            modules: genome.modules.length
        });
        const result = {
            success: true,
            modules: [...genome.modules],
            errors: [],
            warnings: []
        };
        // Load module schemas if not already loaded
        if (this.moduleSchemas.size === 0) {
            await this.loadModuleSchemas(marketplacePath);
        }
        // Deduplicate modules first - keep only the first occurrence of each module ID
        const deduplicatedModules = this.deduplicateModules(result.modules);
        result.modules = deduplicatedModules;
        this.logger.info(`ðŸ”§ Deduplicated modules: ${genome.modules.length} â†’ ${deduplicatedModules.length}`, {
            operation: 'parameter_distribution'
        });
        // Process each capability
        for (const [capabilityName, capabilityConfig] of Object.entries(genome.capabilities || {})) {
            if (!capabilityConfig)
                continue;
            this.logger.info(`  ðŸ“¦ Processing capability: ${capabilityName}`, {
                operation: 'parameter_distribution',
                capability: capabilityName
            });
            const capabilityResult = await this.distributeCapabilityParameters(capabilityName, capabilityConfig, result.modules);
            result.errors.push(...capabilityResult.errors);
            result.warnings.push(...capabilityResult.warnings);
        }
        // Validate all modules have valid parameters
        const validationResult = await this.validateModuleParameters(result.modules);
        result.errors.push(...validationResult.errors);
        result.warnings.push(...validationResult.warnings);
        result.success = result.errors.length === 0;
        this.logger.info(`âœ… Parameter distribution complete`, {
            operation: 'parameter_distribution',
            success: result.success,
            errors: result.errors.length,
            warnings: result.warnings.length
        });
        return result;
    }
    /**
     * Deduplicate modules by ID, keeping only the first occurrence
     */
    deduplicateModules(modules) {
        const seen = new Set();
        const deduplicated = [];
        for (const module of modules) {
            if (!seen.has(module.id)) {
                seen.add(module.id);
                // Create a new module object to avoid reference sharing
                deduplicated.push({
                    id: module.id,
                    category: module.category,
                    version: module.version,
                    parameters: { ...module.parameters }, // Deep copy parameters
                    features: module.features,
                    externalFiles: module.externalFiles,
                    config: module.config
                });
            }
        }
        return deduplicated;
    }
    /**
     * Distribute parameters for a single capability
     */
    async distributeCapabilityParameters(capabilityName, capabilityConfig, modules) {
        const errors = [];
        const warnings = [];
        // Find all distribution rules for this capability
        const capabilityRules = this.distributionRules.filter(rule => rule.capability === capabilityName);
        // Process each rule
        for (const rule of capabilityRules) {
            try {
                // Determine source path (use sourcePath if available, fallback to sourceParameter for legacy)
                const sourcePath = rule.sourcePath || rule.sourceParameter;
                if (!sourcePath) {
                    warnings.push(`Rule missing sourcePath: ${rule.capability}`);
                    continue;
                }
                // Get the source value using nested path access
                const sourceValue = this.getNestedValue(capabilityConfig, sourcePath);
                if (sourceValue === undefined) {
                    continue; // Parameter not provided, skip
                }
                // Apply transformation if defined
                let transformedValue = sourceValue;
                if (rule.transformation) {
                    transformedValue = rule.transformation(sourceValue);
                }
                // Validate the value
                if (rule.validation && !rule.validation(transformedValue)) {
                    errors.push(`Invalid parameter value for ${rule.targetParameter}: ${JSON.stringify(transformedValue)}`);
                    continue;
                }
                // Handle single module or array of modules (for shared parameters)
                const targetModules = Array.isArray(rule.targetModule)
                    ? rule.targetModule
                    : [rule.targetModule];
                // Apply to all target modules
                for (const targetModuleId of targetModules) {
                    // Find the target module
                    const targetModule = modules.find(m => m.id === targetModuleId);
                    if (!targetModule) {
                        warnings.push(`Target module not found: ${targetModuleId}`);
                        continue;
                    }
                    this.logger.debug(`ðŸ” Processing rule: ${rule.capability}.${sourcePath} -> ${targetModuleId}.${rule.targetParameter}`, {
                        operation: 'parameter_distribution',
                        targetModuleId: targetModule.id,
                        targetModuleCategory: targetModule.category
                    });
                    // Skip if this parameter is already applied to this module
                    if (targetModule.parameters && this.getNestedValue(targetModule.parameters, rule.targetParameter) !== undefined) {
                        continue;
                    }
                    // Validate the module can handle this parameter
                    const moduleSchema = this.moduleSchemas.get(targetModuleId);
                    if (moduleSchema && !this.canModuleHandleParameter(moduleSchema, rule.targetParameter, transformedValue)) {
                        warnings.push(`Module ${targetModuleId} may not handle parameter ${rule.targetParameter} correctly`);
                        // Don't skip - continue with application
                    }
                    // Apply the parameter (support nested target parameters)
                    if (!targetModule.parameters) {
                        targetModule.parameters = {};
                    }
                    this.setNestedValue(targetModule.parameters, rule.targetParameter, transformedValue);
                    this.logger.debug(`âœ… Applied parameter: ${targetModuleId}.${rule.targetParameter} = ${JSON.stringify(transformedValue)}`, {
                        operation: 'parameter_distribution',
                        moduleId: targetModule.id,
                        moduleCategory: targetModule.category,
                        allParameters: Object.keys(targetModule.parameters)
                    });
                }
            }
            catch (error) {
                errors.push(`Failed to apply rule ${rule.capability}.${rule.sourcePath || rule.sourceParameter}: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        }
        return { errors, warnings };
    }
    /**
     * Get nested value from object using dot notation
     * Examples:
     * - getNestedValue({a: {b: 1}}, 'a.b') -> 1
     * - getNestedValue({adapter: {oauth: ['google']}}, 'adapter.oauth') -> ['google']
     */
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    }
    /**
     * Set nested value in object using dot notation
     * Creates intermediate objects as needed
     * Examples:
     * - setNestedValue({}, 'features.signIn', true) -> {features: {signIn: true}}
     * - setNestedValue({}, 'oauthProviders', ['google']) -> {oauthProviders: ['google']}
     */
    setNestedValue(obj, path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        // Navigate/create intermediate objects
        let current = obj;
        for (const key of keys) {
            if (!current[key] || typeof current[key] !== 'object') {
                current[key] = {};
            }
            current = current[key];
        }
        // Set the final value
        current[lastKey] = value;
    }
    /**
     * Check if a module can handle a specific parameter
     */
    canModuleHandleParameter(moduleSchema, parameterName, value) {
        const parameterSchema = moduleSchema[parameterName];
        if (!parameterSchema) {
            return false; // Parameter not defined in schema
        }
        // Check type compatibility
        const expectedType = parameterSchema.type;
        const actualType = this.getTypeOfValue(value);
        if (expectedType !== actualType) {
            return false; // Type mismatch
        }
        // Check if value is in allowed options
        if (parameterSchema.options && !parameterSchema.options.includes(value)) {
            return false; // Value not in allowed options
        }
        return true;
    }
    /**
     * Get the type of a value
     */
    getTypeOfValue(value) {
        if (Array.isArray(value))
            return 'array';
        if (value === null)
            return 'object';
        return typeof value;
    }
    /**
     * Validate all module parameters
     */
    async validateModuleParameters(modules) {
        const errors = [];
        const warnings = [];
        for (const module of modules) {
            const moduleSchema = this.moduleSchemas.get(module.id);
            if (!moduleSchema) {
                warnings.push(`No schema found for module: ${module.id}`);
                continue;
            }
            // Validate each parameter
            for (const [paramName, paramValue] of Object.entries(module.parameters || {})) {
                if (!this.canModuleHandleParameter(moduleSchema, paramName, paramValue)) {
                    errors.push(`Module ${module.id} cannot handle parameter ${paramName} with value ${JSON.stringify(paramValue)}`);
                }
            }
            // Check for missing required parameters
            for (const [paramName, paramSchema] of Object.entries(moduleSchema)) {
                if (paramSchema.required && !(paramName in (module.parameters || {}))) {
                    errors.push(`Module ${module.id} is missing required parameter: ${paramName}`);
                }
            }
        }
        return { errors, warnings };
    }
}
//# sourceMappingURL=parameter-distribution.js.map