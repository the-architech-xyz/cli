/**
 * Unified Genome Transformation Service
 *
 * Orchestrates all genome transformations in a single pipeline
 */
import { readFile, access } from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';
export class GenomeTransformationService {
    transformers = [];
    config;
    initialized = false;
    moduleIndex;
    constructor(config) {
        this.config = config;
        // Don't initialize transformers in constructor - wait for first transform call
    }
    /**
     * Transform a genome through the complete pipeline
     */
    async transform(genome) {
        const startTime = Date.now();
        const steps = [];
        // Ensure transformers are loaded
        if (!this.initialized) {
            await this.initializeDefaultTransformers();
            this.initialized = true;
        }
        try {
            // Convert GenomeModule[] to Module[] for internal processing
            // Handle both module-based genomes and capability-based genomes
            const moduleIndex = await this.loadModuleIndex();
            const baseMetadata = { ...(genome.metadata || {}) };
            let currentGenome = {
                ...genome,
                metadata: baseMetadata,
                modules: (genome.modules || []).map(module => this.applyModuleMetadata(module, moduleIndex))
            };
            const context = {
                marketplacePath: this.config.marketplacePath,
                logger: this.config.logger,
                config: this.config,
                metadata: {
                    moduleIndex
                }
            };
            this.config.logger.info('ðŸš€ Starting genome transformation pipeline', {
                originalModules: genome.modules?.length || 0,
                transformers: this.transformers.length,
                hasCapabilities: !!genome.capabilities
            });
            // Sort transformers by priority
            const sortedTransformers = [...this.transformers].sort((a, b) => a.priority - b.priority);
            for (const transformer of sortedTransformers) {
                if (transformer.canTransform(currentGenome)) {
                    const stepStartTime = Date.now();
                    try {
                        this.config.logger.info(`ðŸ”„ Applying ${transformer.name}...`, {
                            transformer: transformer.name,
                            modulesCount: currentGenome.modules.length
                        });
                        currentGenome = await transformer.transform(currentGenome, context);
                        currentGenome.modules = currentGenome.modules.map((moduleItem) => this.applyModuleMetadata(moduleItem, moduleIndex));
                        const stepDuration = Date.now() - stepStartTime;
                        steps.push({
                            transformer: transformer.name,
                            duration: stepDuration,
                            modulesCount: currentGenome.modules.length,
                            success: true
                        });
                        this.config.logger.info(`âœ… ${transformer.name} completed`, {
                            duration: stepDuration,
                            modulesCount: currentGenome.modules.length
                        });
                    }
                    catch (error) {
                        const stepDuration = Date.now() - stepStartTime;
                        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                        steps.push({
                            transformer: transformer.name,
                            duration: stepDuration,
                            modulesCount: currentGenome.modules.length,
                            success: false,
                            error: errorMessage
                        });
                        this.config.logger.error(`âŒ ${transformer.name} failed`, {
                            error: errorMessage,
                            duration: stepDuration
                        });
                        throw error;
                    }
                }
            }
            const totalDuration = Date.now() - startTime;
            this.config.logger.info('ðŸŽ‰ Genome transformation completed successfully', {
                totalDuration,
                steps: steps.length,
                finalModules: currentGenome.modules?.length || 0,
                originalModules: genome.modules?.length || 0
            });
            const serializedModuleIndex = this.serializeModuleIndex(moduleIndex);
            return {
                originalGenome: genome,
                resolvedGenome: {
                    ...currentGenome,
                    modules: currentGenome.modules || [], // Ensure array
                    metadata: {
                        ...(currentGenome.metadata || {}),
                        moduleIndex: serializedModuleIndex,
                        // bootstrap and transformationMode can be added by specific transformers if needed
                    }
                },
                transformationSteps: steps,
                success: true,
                duration: totalDuration
            };
        }
        catch (error) {
            const totalDuration = Date.now() - startTime;
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.config.logger.error('ðŸ’¥ Genome transformation failed', {
                error: errorMessage,
                duration: totalDuration,
                steps: steps.length
            });
            return {
                originalGenome: genome,
                resolvedGenome: {
                    ...genome,
                    modules: genome.modules || [],
                    metadata: {
                        ...(genome.metadata || {}),
                    }
                },
                transformationSteps: steps,
                success: false,
                error: errorMessage,
                duration: totalDuration
            };
        }
    }
    /**
     * Add a custom transformer
     */
    addTransformer(transformer) {
        this.transformers.push(transformer);
        this.config.logger.info(`âž• Added transformer: ${transformer.name}`, {
            priority: transformer.priority,
            description: transformer.description
        });
    }
    /**
     * Remove a transformer by name
     */
    removeTransformer(name) {
        const index = this.transformers.findIndex(t => t.name === name);
        if (index !== -1) {
            const removed = this.transformers.splice(index, 1)[0];
            this.config.logger.info(`âž– Removed transformer: ${removed.name}`);
        }
    }
    /**
     * Get all transformers
     */
    getTransformers() {
        return [...this.transformers];
    }
    /**
     * Get transformer by name
     */
    getTransformer(name) {
        return this.transformers.find(t => t.name === name);
    }
    /**
     * Initialize default transformers
     */
    async initializeDefaultTransformers() {
        // Import transformers dynamically to avoid circular dependencies
        try {
            const { LegacyModuleIdNormalizer } = await import('../transformers/legacy-module-id-normalizer.js');
            this.transformers.push(new LegacyModuleIdNormalizer());
            const { CapabilityNormalizer } = await import('../transformers/capability-normalizer.js');
            if (this.config.options?.enableCapabilityResolution !== false) {
                this.transformers.push(new CapabilityNormalizer());
            }
            const { ManifestFeatureResolver } = await import('../transformers/manifest-feature-resolver.js');
            this.transformers.push(new ManifestFeatureResolver());
            const { ModuleExpander } = await import('../transformers/module-expander.js');
            if (this.config.options?.enableAutoInclusion !== false) {
                this.transformers.push(new ModuleExpander());
            }
            const { ParameterDistributionTransformer } = await import('../transformers/parameter-distribution-transformer.js');
            if (this.config.options?.enableParameterDistribution !== false) {
                this.transformers.push(new ParameterDistributionTransformer());
            }
            const { ConnectorAutoInclusionTransformer } = await import('../transformers/connector-auto-inclusion-transformer.js');
            if (this.config.options?.enableConnectorAutoInclusion !== false) {
                this.transformers.push(new ConnectorAutoInclusionTransformer());
            }
            const { FrameworkStripper } = await import('../transformers/framework-stripper.js');
            this.transformers.push(new FrameworkStripper());
            const { PathRequirementsExtractor } = await import('../transformers/path-requirements-extractor.js');
            this.transformers.push(new PathRequirementsExtractor());
            const { ExecutionOrderTransformer } = await import('../transformers/execution-order-transformer.js');
            this.transformers.push(new ExecutionOrderTransformer());
            const { FinalValidator } = await import('../transformers/final-validator.js');
            this.transformers.push(new FinalValidator());
            this.config.logger.info('ðŸ”§ Initializing default transformers', {
                enabledOptions: {
                    capabilityResolution: this.config.options?.enableCapabilityResolution ?? true,
                    moduleExpansion: this.config.options?.enableAutoInclusion ?? true,
                    parameterDistribution: this.config.options?.enableParameterDistribution ?? true,
                    connectorAutoInclusion: this.config.options?.enableConnectorAutoInclusion ?? true
                },
                transformersLoaded: this.transformers.length
            });
        }
        catch (error) {
            this.config.logger.error('âŒ Failed to initialize transformers', {
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }
    /**
     * Check if genome is capability-driven
     */
    isCapabilityDrivenGenome(genome) {
        return 'capabilities' in genome &&
            typeof genome.capabilities === 'object' &&
            genome.capabilities !== null &&
            Object.keys(genome.capabilities).length > 0;
    }
    async loadModuleIndex() {
        if (this.moduleIndex) {
            return this.moduleIndex;
        }
        const entries = [];
        const manifestCandidates = this.getManifestCandidates();
        let manifestDirectory;
        for (const manifestPath of manifestCandidates) {
            try {
                const manifestContent = await readFile(manifestPath, 'utf-8');
                const manifest = JSON.parse(manifestContent);
                entries.push(...this.extractManifestEntries(manifest));
                manifestDirectory = manifestDirectory ?? path.dirname(manifestPath);
            }
            catch (error) {
                if (error?.code === 'ENOENT') {
                    this.config.logger.debug('â„¹ï¸  Marketplace manifest not found', { path: manifestPath });
                }
                else {
                    this.config.logger.warn('âš ï¸  Failed to load marketplace manifest metadata', {
                        path: manifestPath,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                }
            }
        }
        const capabilityManifestCandidates = this.getCapabilityManifestCandidates(manifestDirectory);
        for (const capabilityManifestPath of capabilityManifestCandidates) {
            try {
                await access(capabilityManifestPath);
                const content = await readFile(capabilityManifestPath, 'utf-8');
                const capabilityManifest = JSON.parse(content);
                entries.push(...this.extractManifestEntries(capabilityManifest));
            }
            catch (error) {
                if (error?.code === 'ENOENT') {
                    continue;
                }
                this.config.logger.warn('âš ï¸  Failed to load capability manifest metadata', {
                    path: capabilityManifestPath,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            }
        }
        const index = new Map();
        for (const entry of entries) {
            index.set(entry.id, entry);
        }
        if (index.size === 0) {
            throw new Error('Marketplace manifest metadata is empty. Regenerate manifests with the updated generators.');
        }
        this.moduleIndex = index;
        this.config.logger.info('ðŸ“¦ Loaded marketplace module metadata', {
            modules: index.size
        });
        return index;
    }
    getManifestCandidates() {
        const candidates = new Set();
        const custom = this.resolveConfigPath(this.config.manifestPath);
        if (custom) {
            candidates.add(custom);
        }
        candidates.add(path.join(this.config.marketplacePath, 'manifest.json'));
        return Array.from(candidates);
    }
    getCapabilityManifestCandidates(manifestDirectory) {
        const candidates = new Set();
        const custom = this.resolveConfigPath(this.config.capabilityManifestPath);
        if (custom) {
            candidates.add(custom);
        }
        const baseDir = manifestDirectory ?? this.config.marketplacePath;
        candidates.add(path.join(baseDir, 'capability-manifest.json'));
        return Array.from(candidates);
    }
    resolveConfigPath(input) {
        if (!input) {
            return undefined;
        }
        let candidate = input;
        if (candidate.startsWith('file://')) {
            try {
                candidate = fileURLToPath(new URL(candidate));
            }
            catch {
                return undefined;
            }
        }
        if (!path.isAbsolute(candidate)) {
            candidate = path.resolve(this.config.marketplacePath, candidate);
        }
        return candidate;
    }
    extractManifestEntries(manifest) {
        if (!manifest?.modules) {
            return [];
        }
        const modules = manifest.modules;
        if (Array.isArray(modules)) {
            return modules
                .map((raw) => this.normalizeManifestEntry(raw))
                .filter((entry) => entry !== null);
        }
        const collected = [];
        for (const categoryKey of ['adapters', 'connectors', 'features', 'capabilities', 'frameworks']) {
            const categoryModules = modules[categoryKey] || [];
            for (const raw of categoryModules) {
                const entry = this.normalizeManifestEntry(raw);
                if (entry) {
                    collected.push(entry);
                }
            }
        }
        return collected;
    }
    normalizeManifestEntry(raw) {
        if (!raw?.id) {
            this.config.logger.warn('âš ï¸  Encountered manifest entry without id', { entry: raw });
            return null;
        }
        if (!raw.source || !raw.manifest || !raw.blueprint) {
            this.config.logger.warn('âš ï¸  Module is missing required metadata (source/manifest/blueprint)', { moduleId: raw.id });
            return null;
        }
        return {
            id: raw.id,
            category: raw.category || raw.type || 'module',
            type: raw.type || raw.category || 'module',
            marketplace: raw.marketplace || { name: 'core' },
            source: {
                root: raw.source.root,
                marketplace: raw.source.marketplace || raw.marketplace?.name || 'core'
            },
            manifest: {
                file: raw.manifest.file
            },
            blueprint: {
                file: raw.blueprint.file,
                runtime: raw.blueprint.runtime || 'source'
            },
            templates: raw.templates || [],
            parameters: raw.parameters || undefined,
            parameterDefaults: raw.parameterDefaults || undefined
        };
    }
    serializeModuleIndex(moduleIndex) {
        const serialized = {};
        for (const [moduleId, entry] of moduleIndex.entries()) {
            const stubModule = {
                id: moduleId,
                category: entry.category || entry.type || 'module',
                parameters: {}
            };
            const enriched = this.applyModuleMetadata({ ...stubModule }, moduleIndex);
            serialized[moduleId] = {
                id: moduleId,
                category: enriched.category,
                type: entry.type,
                marketplace: enriched.marketplace,
                source: enriched.source,
                manifest: enriched.manifest,
                blueprint: enriched.blueprint,
                templates: enriched.templates,
                resolved: enriched.resolved,
                parameters: enriched.parameterSchema,
                parameterDefaults: enriched.parameterDefaults,
                parameterMetadata: enriched.parameterMetadata
            };
        }
        return serialized;
    }
    applyModuleMetadata(module, moduleIndex) {
        const entry = this.resolveModuleEntry(module.id, moduleIndex);
        if (!entry) {
            throw new Error(`Module metadata not found for ${module.id}. Ensure the manifest includes this module.`);
        }
        const marketplaceRoot = module.marketplace?.root
            ? path.resolve(module.marketplace.root)
            : this.config.marketplacePath;
        const source = {
            root: module.source?.root ?? entry.source.root,
            marketplace: module.source?.marketplace ?? entry.source.marketplace
        };
        const manifest = {
            file: module.manifest?.file ?? entry.manifest.file
        };
        const blueprint = {
            file: module.blueprint?.file ?? entry.blueprint.file,
            runtime: module.blueprint?.runtime ?? entry.blueprint.runtime
        };
        const moduleTemplateStrings = Array.isArray(module.templates)
            ? module.templates.map((template) => typeof template === 'string' ? template : template.file)
            : [];
        const combinedTemplates = this.mergeTemplates(entry.templates, moduleTemplateStrings);
        const resolvedTemplates = combinedTemplates.map(template => this.resolvePath(marketplaceRoot, template));
        const templateObjects = combinedTemplates.map((template) => typeof template === 'string' ? { file: template } : template);
        const parameterDefaults = module.parameterDefaults ?? this.extractParameterDefaults(entry.parameters);
        const parameterMetadata = module.parameterMetadata ?? entry.parameters;
        return {
            ...module,
            category: module.category ?? entry.category ?? entry.type,
            source,
            manifest,
            blueprint,
            templates: templateObjects,
            marketplace: {
                name: module.marketplace?.name ?? entry.marketplace?.name ?? 'core',
                root: marketplaceRoot
            },
            parameterSchema: module.parameterSchema ?? entry.parameters,
            parameterDefaults,
            parameterMetadata,
            resolved: {
                root: this.resolvePath(marketplaceRoot, source.root),
                manifest: this.resolvePath(marketplaceRoot, manifest.file),
                blueprint: this.resolvePath(marketplaceRoot, blueprint.file),
                templates: Array.from(new Set(resolvedTemplates))
            }
        };
    }
    resolvePath(basePath, filePath) {
        if (path.isAbsolute(filePath)) {
            return filePath;
        }
        return path.join(basePath, filePath);
    }
    mergeTemplates(entryTemplates, moduleTemplates) {
        const templates = new Set();
        for (const template of entryTemplates || []) {
            templates.add(template);
        }
        for (const template of moduleTemplates || []) {
            templates.add(template);
        }
        return Array.from(templates);
    }
    extractParameterDefaults(parameters) {
        if (!parameters) {
            return undefined;
        }
        const defaults = {};
        for (const [key, definition] of Object.entries(parameters)) {
            if (definition && typeof definition === 'object' && 'default' in definition) {
                defaults[key] = definition.default;
            }
        }
        return Object.keys(defaults).length > 0 ? defaults : undefined;
    }
    resolveModuleEntry(moduleId, moduleIndex) {
        if (!moduleIndex) {
            return undefined;
        }
        const lookup = (id) => {
            if (moduleIndex instanceof Map) {
                return moduleIndex.get(id);
            }
            return moduleIndex[id];
        };
        const candidates = new Set();
        candidates.add(moduleId);
        if (moduleId.startsWith('adapters/')) {
            candidates.add(moduleId.replace(/^adapters\//, ''));
        }
        if (moduleId.startsWith('modules/')) {
            candidates.add(moduleId.replace(/^modules\//, ''));
        }
        for (const candidate of candidates) {
            const entry = lookup(candidate);
            if (entry) {
                return entry;
            }
        }
        return undefined;
    }
}
//# sourceMappingURL=transformation-service.js.map