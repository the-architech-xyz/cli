/**
 * Module Expansion Transformer
 *
 * Expands feature modules and adds required dependencies
 */
import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class ModuleExpander extends BaseGenomeTransformer {
    name = 'Module Expansion';
    priority = 2; // After capability normalization
    description = 'Expands feature modules and adds required dependencies';
    canTransform(genome) {
        return genome.modules && genome.modules.length > 0;
    }
    async transform(genome, context) {
        this.logStep(context, 'Expanding modules and adding dependencies', {
            modules: genome.modules.length
        });
        let expandedModules = [...genome.modules];
        // Expand feature modules
        expandedModules = await this.expandFeatureModules(expandedModules, context);
        // Add required adapters
        expandedModules = await this.addRequiredAdapters(expandedModules, context);
        // Add marketplace defaults
        expandedModules = await this.addMarketplaceDefaults(expandedModules, context);
        this.logSuccess(context, 'Module expansion complete', {
            originalModules: genome.modules.length,
            expandedModules: expandedModules.length,
            addedModules: expandedModules.length - genome.modules.length
        });
        return {
            ...genome,
            modules: expandedModules
        };
    }
    async expandFeatureModules(modules, context) {
        const expandedModules = [];
        for (const module of modules) {
            expandedModules.push(module);
            // If it's a feature module, check if it needs expansion
            if (module.category === 'features') {
                const featureModules = await this.getRequiredFeatureModules(module, context);
                expandedModules.push(...featureModules);
            }
        }
        return expandedModules;
    }
    async addRequiredAdapters(modules, context) {
        const adapterModules = [];
        const addedAdapters = new Set();
        for (const module of modules) {
            if (module.category === 'features') {
                const requiredAdapters = await this.getRequiredAdapters(module, context);
                for (const adapter of requiredAdapters) {
                    if (!addedAdapters.has(adapter.id)) {
                        adapterModules.push(adapter);
                        addedAdapters.add(adapter.id);
                    }
                }
            }
        }
        return [...modules, ...adapterModules];
    }
    async addMarketplaceDefaults(modules, context) {
        const defaultModules = [];
        const addedDefaults = new Set();
        const moduleIndex = this.getModuleIndex(context);
        const coreAdapters = [
            'adapters/core/framework',
            'adapters/core/monorepo',
            'adapters/core/ui'
        ];
        for (const adapterId of coreAdapters) {
            if (modules.some(m => m.id === adapterId) || addedDefaults.has(adapterId)) {
                continue;
            }
            const metadata = moduleIndex.get(adapterId);
            if (!metadata) {
                context.logger.debug(`Skipping default adapter (metadata missing): ${adapterId}`);
                continue;
            }
            defaultModules.push({
                id: adapterId,
                category: metadata.category || metadata.type || 'adapters',
                parameters: {}
            });
            addedDefaults.add(adapterId);
        }
        return [...modules, ...defaultModules];
    }
    async getRequiredFeatureModules(module, context) {
        const featureModules = [];
        const featureName = this.extractFeatureName(module.id);
        const moduleIndex = this.getModuleIndex(context);
        if (!featureName)
            return featureModules;
        const candidateIds = [
            `features/${featureName}/tech-stack`,
            `features/${featureName}/frontend`
        ];
        for (const candidateId of candidateIds) {
            const metadata = moduleIndex.get(candidateId);
            if (!metadata) {
                continue;
            }
            featureModules.push({
                id: candidateId,
                category: metadata.category || metadata.type || 'features',
                parameters: module.parameters
            });
        }
        return featureModules;
    }
    async getRequiredAdapters(module, context) {
        const adapters = [];
        const featureName = this.extractFeatureName(module.id);
        const moduleIndex = this.getModuleIndex(context);
        if (!featureName)
            return adapters;
        const adapterId = `adapters/${featureName}`;
        const metadata = moduleIndex.get(adapterId);
        if (metadata) {
            adapters.push({
                id: adapterId,
                category: metadata.category || metadata.type || 'adapters',
                parameters: {}
            });
        }
        return adapters;
    }
    getModuleIndex(context) {
        const index = context.metadata?.moduleIndex;
        if (!index) {
            throw new Error('Module index metadata missing from transformation context. Ensure transformation service loads marketplace metadata.');
        }
        return index;
    }
    extractFeatureName(moduleId) {
        const parts = moduleId.split('/');
        if (parts.length >= 2 && parts[0] === 'features') {
            return parts[1] || null;
        }
        return null;
    }
}
//# sourceMappingURL=module-expander.js.map