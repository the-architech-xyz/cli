/**
 * Connector Auto-Inclusion Transformer
 *
 * Automatically adds connectors that bridge technologies selected by the user.
 * Analyzes resolved modules and identifies technology gaps that need bridging.
 */
import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class ConnectorAutoInclusionTransformer extends BaseGenomeTransformer {
    name = 'Connector Auto-Inclusion';
    priority = 4; // After parameter distribution
    description = 'Automatically adds connectors that bridge selected technologies';
    technologyBridges = [];
    constructor() {
        super();
        this.initializeTechnologyBridges();
    }
    canTransform(genome) {
        // Only transform if genome has modules that might need connectors
        return genome.modules.length > 0;
    }
    async transform(genome, context) {
        this.logStep(context, 'Analyzing modules for connector requirements', {
            modules: genome.modules.length
        });
        try {
            const existingModules = new Set(genome.modules.map(m => m.id));
            const addedConnectors = [];
            // First, search for all available connectors in the marketplace
            const availableConnectors = await this.searchConnectorsInMarketplace(context);
            context.logger.debug(`Found ${availableConnectors.length} connectors in marketplace`, {
                operation: 'connector_auto_inclusion'
            });
            // Analyze each module for connector requirements
            for (const module of genome.modules) {
                const requiredConnectors = this.findRequiredConnectors(module, existingModules);
                for (const connectorId of requiredConnectors) {
                    if (!existingModules.has(connectorId)) {
                        // Check if connector exists in marketplace
                        if (availableConnectors.includes(connectorId)) {
                            const connectorModule = await this.createConnectorModule(connectorId, context);
                            if (connectorModule) {
                                addedConnectors.push(connectorModule);
                                existingModules.add(connectorId);
                                context.logger.debug(`Added connector: ${connectorId}`, {
                                    connector: connectorId,
                                    requiredBy: module.id
                                });
                            }
                        }
                        else {
                            context.logger.debug(`Connector not found in marketplace: ${connectorId}`, {
                                connector: connectorId,
                                requiredBy: module.id
                            });
                        }
                    }
                }
            }
            const result = {
                ...genome,
                modules: [...genome.modules, ...addedConnectors]
            };
            this.logSuccess(context, 'Connector auto-inclusion complete', {
                originalModules: genome.modules.length,
                addedConnectors: addedConnectors.length,
                finalModules: result.modules.length,
                availableConnectors: availableConnectors.length
            });
            return result;
        }
        catch (error) {
            context.logger.error('Connector auto-inclusion failed', {
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            // Return genome unchanged on error
            return genome;
        }
    }
    async validate(genome) {
        const errors = [];
        const warnings = [];
        // Validate that connectors exist in marketplace
        const connectorModules = genome.modules.filter(m => m.id.startsWith('connectors/'));
        for (const connector of connectorModules) {
            try {
                const fs = await import('fs/promises');
                const path = await import('path');
                // Check if connector exists in marketplace
                const connectorPath = path.join('/Users/antoine/Documents/Code/architech/marketplace', connector.id, 'connector.json');
                await fs.access(connectorPath);
            }
            catch (error) {
                errors.push(`Connector not found in marketplace: ${connector.id}`);
            }
        }
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    /**
     * Initialize technology bridges
     */
    initializeTechnologyBridges() {
        this.technologyBridges = [
            // Auth bridges
            {
                from: 'adapters/auth/better-auth',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/auth/better-auth-nextjs',
                required: true
            },
            {
                from: 'adapters/auth/better-auth',
                to: 'adapters/framework/expo',
                connectorId: 'connectors/auth/better-auth-expo',
                required: true
            },
            {
                from: 'adapters/auth/better-auth',
                to: 'adapters/framework/react-native',
                connectorId: 'connectors/auth/better-auth-react-native',
                required: true
            },
            // Payment bridges
            {
                from: 'adapters/payment/stripe',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/payment/stripe-nextjs',
                required: true
            },
            {
                from: 'adapters/payment/revenuecat',
                to: 'adapters/framework/expo',
                connectorId: 'connectors/revenuecat-expo',
                required: true
            },
            {
                from: 'adapters/payment/revenuecat',
                to: 'adapters/framework/react-native',
                connectorId: 'connectors/revenuecat-react-native',
                required: true
            },
            // Database bridges
            {
                from: 'adapters/database/postgres',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/database/postgres-nextjs',
                required: true
            },
            {
                from: 'adapters/database/drizzle',
                to: 'adapters/database/postgres',
                connectorId: 'connectors/database/drizzle-postgres-docker',
                required: true
            },
            // Email bridges
            {
                from: 'adapters/email/resend',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/email/resend-nextjs',
                required: true
            },
            // Monitoring bridges
            {
                from: 'adapters/observability/sentry',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/monitoring/sentry-nextjs',
                required: true
            },
            // Data fetching bridges
            {
                from: 'adapters/data-fetching/trpc',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/nextjs-trpc-router',
                required: true
            },
            // Testing bridges
            {
                from: 'adapters/testing/vitest',
                to: 'adapters/framework/nextjs',
                connectorId: 'connectors/testing/vitest-nextjs',
                required: true
            }
        ];
    }
    /**
     * Find required connectors for a module
     */
    findRequiredConnectors(module, existingModules) {
        const requiredConnectors = [];
        // Check if this module needs connectors
        for (const bridge of this.technologyBridges) {
            if (bridge.from === module.id) {
                // Check if the target technology exists
                if (existingModules.has(bridge.to)) {
                    // Check if connector is already included
                    if (!existingModules.has(bridge.connectorId)) {
                        requiredConnectors.push(bridge.connectorId);
                    }
                }
            }
        }
        // Also search for dynamic connectors based on module patterns
        const dynamicConnectors = this.findDynamicConnectors(module, existingModules);
        requiredConnectors.push(...dynamicConnectors);
        return requiredConnectors;
    }
    /**
     * Find dynamic connectors based on module patterns
     */
    findDynamicConnectors(module, existingModules) {
        const dynamicConnectors = [];
        // Extract capability and provider from module ID
        const moduleParts = module.id.split('/');
        if (moduleParts.length < 3)
            return dynamicConnectors;
        const [, capability, provider] = moduleParts;
        // Look for framework adapters to bridge with
        const frameworkModules = Array.from(existingModules).filter(id => id.startsWith('adapters/framework/'));
        for (const frameworkId of frameworkModules) {
            const frameworkParts = frameworkId.split('/');
            const framework = frameworkParts[frameworkParts.length - 1];
            // Try to find a connector that bridges this capability+provider with the framework
            const potentialConnectorId = `connectors/${capability}/${provider}-${framework}`;
            // Check if this connector exists and isn't already included
            if (!existingModules.has(potentialConnectorId)) {
                dynamicConnectors.push(potentialConnectorId);
            }
        }
        return dynamicConnectors;
    }
    /**
     * Search for connectors in the marketplace
     */
    async searchConnectorsInMarketplace(context, pattern) {
        try {
            const fs = await import('fs/promises');
            const path = await import('path');
            const connectorsPath = path.join(context.marketplacePath, 'connectors');
            // Check if connectors directory exists
            try {
                await fs.access(connectorsPath);
            }
            catch {
                return [];
            }
            const connectors = [];
            // Recursively search for connector.json files
            const searchDirectory = async (dir, basePath = '') => {
                const entries = await fs.readdir(dir, { withFileTypes: true });
                for (const entry of entries) {
                    const fullPath = path.join(dir, entry.name);
                    const relativePath = path.join(basePath, entry.name);
                    if (entry.isDirectory()) {
                        await searchDirectory(fullPath, relativePath);
                    }
                    else if (entry.name === 'connector.json') {
                        const connectorId = `connectors/${relativePath.replace(/\\/g, '/').replace('/connector.json', '')}`;
                        // Apply pattern filter if provided
                        if (!pattern || connectorId.includes(pattern)) {
                            connectors.push(connectorId);
                        }
                    }
                }
            };
            await searchDirectory(connectorsPath);
            return connectors;
        }
        catch (error) {
            context.logger.warn('Failed to search connectors in marketplace', {
                operation: 'connector_search',
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            return [];
        }
    }
    /**
     * Create a connector module
     */
    async createConnectorModule(connectorId, context) {
        try {
            // Check if connector exists in marketplace
            const fs = await import('fs/promises');
            const path = await import('path');
            const connectorPath = path.join(context.marketplacePath, connectorId, 'connector.json');
            await fs.access(connectorPath);
            // Load connector schema to get default parameters
            const connectorContent = await fs.readFile(connectorPath, 'utf8');
            const connectorSchema = JSON.parse(connectorContent);
            // Create module with default parameters
            const module = {
                id: connectorId,
                category: 'connector',
                parameters: this.extractDefaultParameters(connectorSchema.parameters || {}),
                features: {},
                externalFiles: [],
                config: undefined
            };
            return module;
        }
        catch (error) {
            context.logger.warn(`Connector not found: ${connectorId}`, {
                operation: 'connector_auto_inclusion',
                connector: connectorId,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            return null;
        }
    }
    /**
     * Extract default parameters from connector schema
     */
    extractDefaultParameters(parameterSchema) {
        const defaults = {};
        for (const [paramName, paramDef] of Object.entries(parameterSchema)) {
            if (paramDef && typeof paramDef === 'object' && 'default' in paramDef) {
                defaults[paramName] = paramDef.default;
            }
        }
        return defaults;
    }
}
//# sourceMappingURL=connector-auto-inclusion-transformer.js.map