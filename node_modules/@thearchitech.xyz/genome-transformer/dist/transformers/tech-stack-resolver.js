/**
 * Tech-Stack Resolution Transformer
 *
 * Detects and applies tech-stack overrides (tRPC, SDK overrides)
 */
import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class TechStackResolver extends BaseGenomeTransformer {
    name = 'Tech-Stack Resolution';
    priority = 3; // After capability normalization and module expansion
    description = 'Applies tech-stack overrides based on detected technologies';
    canTransform(genome) {
        return genome.modules && genome.modules.length > 0;
    }
    async transform(genome, context) {
        this.logStep(context, 'Resolving tech-stack overrides', {
            modules: genome.modules.length
        });
        let enhancedModules = [...genome.modules];
        // Detect tRPC usage
        const trpcConfig = await this.detectTRPCUsage(enhancedModules, context);
        if (trpcConfig.enabled) {
            this.logStep(context, 'tRPC detected, applying overrides', {
                features: trpcConfig.features
            });
            enhancedModules = await this.applyTRPCOverrides(enhancedModules, trpcConfig, context);
        }
        // Detect SDK overrides
        const sdkOverrides = await this.detectSDKOverrides(enhancedModules, context);
        if (sdkOverrides.length > 0) {
            this.logStep(context, 'SDK overrides detected', {
                overrides: sdkOverrides
            });
            enhancedModules = await this.applySDKOverrides(enhancedModules, sdkOverrides, context);
        }
        this.logSuccess(context, 'Tech-stack resolution complete', {
            originalModules: genome.modules.length,
            enhancedModules: enhancedModules.length,
            addedModules: enhancedModules.length - genome.modules.length
        });
        return {
            ...genome,
            modules: enhancedModules
        };
    }
    async detectTRPCUsage(modules, context) {
        // Check for tRPC in data-fetching adapters
        const trpcModules = modules.filter(module => module.id.includes('data-fetching/trpc') ||
            module.id.includes('connectors/trpc'));
        if (trpcModules.length === 0) {
            return { enabled: false, features: [] };
        }
        // Find features that support tRPC overrides
        const features = modules
            .filter(module => module.category === 'features')
            .map(module => this.extractFeatureName(module.id))
            .filter(name => name !== null);
        return {
            enabled: true,
            features,
            routerPath: 'src/server/api/trpc.ts' // Default path
        };
    }
    async applyTRPCOverrides(modules, trpcConfig, context) {
        const overrideModules = [];
        for (const feature of trpcConfig.features) {
            try {
                const overrideId = `features/_shared/tech-stack/overrides/trpc`;
                const overridePath = `${context.marketplacePath}/${overrideId}`;
                const fs = await import('fs/promises');
                await fs.access(`${overridePath}/adapter.json`);
                overrideModules.push({
                    id: `${overrideId}-${feature}`,
                    category: 'features',
                    parameters: {
                        feature,
                        routerPath: trpcConfig.routerPath
                    }
                });
                this.logStep(context, `Added tRPC override for ${feature}`);
            }
            catch (error) {
                context.logger.warn(`⚠️ tRPC override not found for ${feature}`);
            }
        }
        return [...modules, ...overrideModules];
    }
    async detectSDKOverrides(modules, context) {
        const sdkOverrides = [];
        // Check for Better Auth
        const betterAuthModules = modules.filter(module => module.id.includes('auth/better-auth'));
        if (betterAuthModules.length > 0) {
            sdkOverrides.push('better-auth');
        }
        // Check for RevenueCat
        const revenueCatModules = modules.filter(module => module.id.includes('payments/revenuecat'));
        if (revenueCatModules.length > 0) {
            sdkOverrides.push('revenuecat');
        }
        // Check for Stripe
        const stripeModules = modules.filter(module => module.id.includes('payments/stripe'));
        if (stripeModules.length > 0) {
            sdkOverrides.push('stripe');
        }
        return sdkOverrides;
    }
    async applySDKOverrides(modules, sdkOverrides, context) {
        const overrideModules = [];
        for (const sdk of sdkOverrides) {
            try {
                // Find tech-stack modules that can be overridden
                const techStackModules = modules.filter(module => module.category === 'features' &&
                    module.id.includes('/tech-stack'));
                for (const techStackModule of techStackModules) {
                    const featureName = this.extractFeatureName(techStackModule.id);
                    if (!featureName)
                        continue;
                    const overrideId = `features/${featureName}/tech-stack/overrides/${sdk}`;
                    const overridePath = `${context.marketplacePath}/${overrideId}`;
                    const fs = await import('fs/promises');
                    await fs.access(`${overridePath}/adapter.json`);
                    overrideModules.push({
                        id: overrideId,
                        category: 'features',
                        parameters: techStackModule.parameters
                    });
                    this.logStep(context, `Added ${sdk} override for ${featureName}`);
                }
            }
            catch (error) {
                context.logger.warn(`⚠️ ${sdk} override not found`);
            }
        }
        return [...modules, ...overrideModules];
    }
    extractFeatureName(moduleId) {
        const parts = moduleId.split('/');
        if (parts.length >= 2 && parts[0] === 'features') {
            return parts[1] || null;
        }
        return null;
    }
}
//# sourceMappingURL=tech-stack-resolver.js.map