/**
 * Capability Normalization Transformer
 *
 * Converts capability-driven genomes to traditional module-based genomes
 */
import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class CapabilityNormalizer extends BaseGenomeTransformer {
    name = 'Capability Normalization';
    priority = 1; // First transformer
    description = 'Converts capability declarations to executable modules';
    canTransform(genome) {
        // Transform if has capabilities OR has framework (need to auto-include framework module)
        return this.isCapabilityDrivenGenome(genome) || !!genome.project?.framework;
    }
    async transform(genome, context) {
        const modules = [...(genome.modules || [])];
        // 1. Auto-include framework module based on project.framework (always needed)
        if (genome.project?.framework) {
            const frameworkModule = await this.resolveFrameworkModule(genome.project.framework, context);
            if (frameworkModule && !modules.some(m => m.id === frameworkModule.id)) {
                modules.unshift(frameworkModule); // Add framework first (required by orchestrator)
                this.logStep(context, `Auto-included framework module: ${frameworkModule.id}`, {
                    framework: genome.project.framework
                });
            }
        }
        // 2. Resolve capabilities (if any)
        if (this.isCapabilityDrivenGenome(genome)) {
            this.logStep(context, 'Converting capabilities to modules', {
                capabilities: Object.keys(genome.capabilities)
            });
            const resolvedModules = await this.resolveCapabilities(genome.capabilities, context);
            modules.push(...resolvedModules);
            this.logSuccess(context, 'Capability resolution complete', {
                resolvedModules: resolvedModules.length,
                capabilities: Object.keys(genome.capabilities)
            });
        }
        return {
            ...genome,
            modules
        };
    }
    async resolveCapabilities(capabilities, context) {
        const modules = [];
        for (const [capabilityName, config] of Object.entries(capabilities)) {
            this.logStep(context, `Resolving ${capabilityName} capability`, {
                provider: config.provider,
                hasAdapter: !!config.adapter,
                hasFrontend: !!config.frontend,
                hasTechStack: !!config.techStack
            });
            // 1. Resolve adapter (if provider specified)
            if (config.provider) {
                const adapterModule = await this.resolveAdapter(capabilityName, config.provider, context);
                if (adapterModule) {
                    modules.push(adapterModule);
                }
            }
            // 2. Always resolve frontend layer (no flag check - capability implies frontend)
            // Frontend is included by default when a capability is specified
            const frontendModule = await this.resolveFrontendLayer(capabilityName, config, context);
            if (frontendModule) {
                modules.push(frontendModule);
            }
            // 3. Always resolve tech-stack layer (no flag check - capability implies tech-stack)
            // Tech-stack is included by default when a capability is specified
            const techStackModule = await this.resolveTechStackLayer(capabilityName, config, context);
            if (techStackModule) {
                modules.push(techStackModule);
            }
            // 4. Resolve backend layer (only if explicitly configured)
            if (config.backend) {
                const backendModule = await this.resolveBackendLayer(capabilityName, config, context);
                if (backendModule) {
                    modules.push(backendModule);
                }
            }
            // 5. Resolve database layer (only if explicitly configured)
            if (config.database) {
                const databaseModule = await this.resolveDatabaseLayer(capabilityName, config, context);
                if (databaseModule) {
                    modules.push(databaseModule);
                }
            }
        }
        return modules;
    }
    /**
     * Auto-resolve framework module from project.framework
     */
    async resolveFrameworkModule(framework, context) {
        // Handle special cases
        if (framework === 'multi') {
            // For monorepos with multiple frameworks, we'll need to handle this differently
            // For now, default to nextjs for the web package
            framework = 'nextjs';
        }
        const frameworkId = `adapters/framework/${framework}`;
        try {
            const frameworkPath = `${context.marketplacePath}/${frameworkId}`;
            const fs = await import('fs/promises');
            await fs.access(`${frameworkPath}/adapter.json`);
            return {
                id: frameworkId,
                category: 'adapters',
                parameters: {}
            };
        }
        catch {
            // Try legacy format
            const legacyFrameworkId = `framework/${framework}`;
            try {
                const legacyFrameworkPath = `${context.marketplacePath}/${legacyFrameworkId}`;
                const fs = await import('fs/promises');
                await fs.access(`${legacyFrameworkPath}/adapter.json`);
                return {
                    id: legacyFrameworkId,
                    category: 'framework',
                    parameters: {}
                };
            }
            catch {
                context.logger.warn(`⚠️ Framework adapter not found: ${frameworkId} or ${legacyFrameworkId}`);
                return null;
            }
        }
    }
    async resolveAdapter(capabilityName, provider, context) {
        // Map provider names to actual adapter names and handle capability name variations
        const providerMapping = {
            'better-auth-nextjs': 'better-auth',
            'stripe-nextjs': 'stripe',
            'revenuecat-nextjs': 'revenuecat',
            'resend-nextjs': 'resend',
            'sentry-nextjs': 'sentry'
        };
        // Handle capability name variations (e.g., payments -> payment)
        const capabilityMapping = {
            'payments': 'payment',
            'emailing': 'email',
            'monitoring': 'observability'
        };
        const actualProvider = providerMapping[provider] || provider;
        const actualCapability = capabilityMapping[capabilityName] || capabilityName;
        const adapterId = `adapters/${actualCapability}/${actualProvider}`;
        try {
            // Check if adapter exists in marketplace
            const adapterPath = `${context.marketplacePath}/adapters/${actualCapability}/${actualProvider}`;
            const fs = await import('fs/promises');
            await fs.access(`${adapterPath}/adapter.json`);
            return {
                id: adapterId,
                category: 'adapters',
                parameters: {}
            };
        }
        catch {
            context.logger.warn(`⚠️ Adapter not found: ${adapterId}`);
            return null;
        }
    }
    async resolveTechStackLayer(capabilityName, config, context) {
        const techStackId = `features/${capabilityName}/tech-stack`;
        try {
            const techStackPath = `${context.marketplacePath}/features/${capabilityName}/tech-stack`;
            const fs = await import('fs/promises');
            await fs.access(`${techStackPath}/feature.json`);
            return {
                id: techStackId,
                category: 'features',
                parameters: {} // Don't add capability parameters here - let ParameterDistributionTransformer handle it
            };
        }
        catch {
            context.logger.warn(`⚠️ Tech-stack layer not found: ${techStackId}`);
            return null;
        }
    }
    async resolveFrontendLayer(capabilityName, config, context) {
        const frontendId = `features/${capabilityName}/frontend`;
        try {
            const frontendPath = `${context.marketplacePath}/features/${capabilityName}/frontend`;
            const fs = await import('fs/promises');
            await fs.access(`${frontendPath}/feature.json`);
            return {
                id: frontendId,
                category: 'features',
                parameters: {} // Don't add capability parameters here - let ParameterDistributionTransformer handle it
            };
        }
        catch {
            context.logger.warn(`⚠️ Frontend layer not found: ${frontendId}`);
            return null;
        }
    }
    async resolveBackendLayer(capabilityName, config, context) {
        const backendId = `features/${capabilityName}/backend`;
        try {
            const backendPath = `${context.marketplacePath}/features/${capabilityName}/backend`;
            const fs = await import('fs/promises');
            await fs.access(`${backendPath}/feature.json`);
            return {
                id: backendId,
                category: 'features',
                parameters: {} // Don't add capability parameters here - let ParameterDistributionTransformer handle it
            };
        }
        catch {
            context.logger.warn(`⚠️ Backend layer not found: ${backendId}`);
            return null;
        }
    }
    async resolveDatabaseLayer(capabilityName, config, context) {
        const databaseId = `features/${capabilityName}/database`;
        try {
            const databasePath = `${context.marketplacePath}/features/${capabilityName}/database`;
            const fs = await import('fs/promises');
            await fs.access(`${databasePath}/feature.json`);
            return {
                id: databaseId,
                category: 'features',
                parameters: {} // Don't add capability parameters here - let ParameterDistributionTransformer handle it
            };
        }
        catch {
            context.logger.warn(`⚠️ Database layer not found: ${databaseId}`);
            return null;
        }
    }
    isCapabilityDrivenGenome(genome) {
        return 'capabilities' in genome &&
            typeof genome.capabilities === 'object' &&
            genome.capabilities !== null &&
            Object.keys(genome.capabilities).length > 0;
    }
}
//# sourceMappingURL=capability-normalizer.js.map