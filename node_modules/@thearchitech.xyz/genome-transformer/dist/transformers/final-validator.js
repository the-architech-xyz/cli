/**
 * Final Validation Transformer
 *
 * Performs final validation and preparation for execution
 */
import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class FinalValidator extends BaseGenomeTransformer {
    name = 'Final Validation';
    priority = 5; // Last transformer
    description = 'Performs final validation and preparation for execution';
    canTransform(genome) {
        return genome.modules && genome.modules.length > 0;
    }
    async transform(genome, context) {
        this.logStep(context, 'Performing final validation', {
            modules: genome.modules.length
        });
        // Validate all modules exist
        const validationResult = await this.validateModules(genome.modules, context);
        if (!validationResult.valid) {
            const errorMessage = `Validation failed: ${validationResult.errors.join(', ')}`;
            this.logError(context, errorMessage, new Error(errorMessage));
            throw new Error(errorMessage);
        }
        // Log warnings
        if (validationResult.warnings.length > 0) {
            context.logger.warn('⚠️ Validation warnings', {
                warnings: validationResult.warnings
            });
        }
        // Check for conflicts
        const conflicts = await this.detectConflicts(genome.modules, context);
        if (conflicts.length > 0) {
            context.logger.warn('⚠️ Module conflicts detected', {
                conflicts
            });
        }
        // Prepare for execution
        const preparedGenome = await this.prepareForExecution(genome, context);
        this.logSuccess(context, 'Final validation complete', {
            modules: preparedGenome.modules.length,
            warnings: validationResult.warnings.length,
            conflicts: conflicts.length
        });
        return preparedGenome;
    }
    async validate(genome) {
        const errors = [];
        const warnings = [];
        // Check genome structure
        if (!genome.version) {
            errors.push('Genome missing version');
        }
        if (!genome.project) {
            errors.push('Genome missing project configuration');
        }
        if (!genome.modules || genome.modules.length === 0) {
            errors.push('Genome has no modules');
        }
        // Check for duplicate modules
        const moduleIds = genome.modules.map(m => m.id);
        const duplicates = moduleIds.filter((id, index) => moduleIds.indexOf(id) !== index);
        if (duplicates.length > 0) {
            errors.push(`Duplicate modules found: ${duplicates.join(', ')}`);
        }
        // Check for invalid module IDs
        for (const module of genome.modules) {
            if (!module.id || typeof module.id !== 'string') {
                errors.push(`Invalid module ID: ${module.id}`);
            }
            if (module.category && typeof module.category !== 'string') {
                errors.push(`Invalid module category: ${module.category}`);
            }
        }
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    async validateModules(modules, context) {
        const errors = [];
        const warnings = [];
        const fs = await import('fs/promises');
        for (const module of modules) {
            if (!module.resolved) {
                errors.push(`Module missing resolved metadata: ${module.id}`);
                continue;
            }
            try {
                await fs.access(module.resolved.root);
            }
            catch {
                errors.push(`Module root not found: ${module.id} (${module.resolved.root})`);
                continue;
            }
            if (!module.resolved.manifest) {
                errors.push(`Module manifest path missing: ${module.id}`);
                continue;
            }
            try {
                await fs.access(module.resolved.manifest);
            }
            catch {
                errors.push(`Module manifest not found: ${module.id} (${module.resolved.manifest})`);
            }
            if (!module.resolved.blueprint) {
                warnings.push(`Module blueprint path missing: ${module.id}`);
            }
            else {
                try {
                    await fs.access(module.resolved.blueprint);
                }
                catch {
                    warnings.push(`Module blueprint not found: ${module.id} (${module.resolved.blueprint})`);
                }
            }
            if (module.resolved.templates && module.resolved.templates.length > 0) {
                for (const templatePath of module.resolved.templates) {
                    try {
                        await fs.access(templatePath);
                    }
                    catch {
                        warnings.push(`Template missing for ${module.id}: ${templatePath}`);
                    }
                }
            }
        }
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    async detectConflicts(modules, context) {
        const conflicts = [];
        // Group modules by category and feature
        const moduleGroups = new Map();
        for (const module of modules) {
            const key = `${module.category}-${this.extractFeatureName(module.id)}`;
            if (!moduleGroups.has(key)) {
                moduleGroups.set(key, []);
            }
            moduleGroups.get(key).push(module);
        }
        // Check for conflicts within groups
        for (const [groupKey, groupModules] of moduleGroups) {
            if (groupModules.length > 1) {
                // Check for override conflicts
                const overrideModules = groupModules.filter(m => m.id.includes('/overrides/'));
                if (overrideModules.length > 1) {
                    conflicts.push(`Multiple overrides for ${groupKey}: ${overrideModules.map(m => m.id).join(', ')}`);
                }
            }
        }
        return conflicts;
    }
    async prepareForExecution(genome, context) {
        // Sort modules by execution order
        const sortedModules = this.sortModulesByExecutionOrder(genome.modules);
        // Add execution metadata
        const preparedGenome = {
            ...genome,
            modules: sortedModules,
            metadata: {
                ...genome.metadata,
                executionOrder: sortedModules.map(m => m.id),
                transformationComplete: true,
                transformedAt: new Date().toISOString()
            }
        };
        return preparedGenome;
    }
    sortModulesByExecutionOrder(modules) {
        const executionOrder = [
            'adapters',
            'connectors',
            'features',
            'ui'
        ];
        return modules.sort((a, b) => {
            const aCategory = a.category || 'unknown';
            const bCategory = b.category || 'unknown';
            const aIndex = executionOrder.indexOf(aCategory);
            const bIndex = executionOrder.indexOf(bCategory);
            if (aIndex === -1 && bIndex === -1)
                return 0;
            if (aIndex === -1)
                return 1;
            if (bIndex === -1)
                return -1;
            return aIndex - bIndex;
        });
    }
    extractFeatureName(moduleId) {
        const parts = moduleId.split('/');
        if (parts.length >= 2 && parts[0] === 'features') {
            return parts[1] || null;
        }
        return null;
    }
}
//# sourceMappingURL=final-validator.js.map