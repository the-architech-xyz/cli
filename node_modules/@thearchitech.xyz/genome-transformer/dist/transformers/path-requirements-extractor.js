/**
 * Path Requirements Extractor Transformer
 *
 * Extracts path requirements from resolved modules by analyzing:
 * - Domain categories (auth, payment, monitoring, etc.)
 * - Module types and their typical path needs
 * - Feature-specific subdirectory requirements
 *
 * This information is added to genome.metadata.pathRequirements for use by
 * the marketplace adapter when generating paths.
 */
import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class PathRequirementsExtractor extends BaseGenomeTransformer {
    name = 'Path Requirements Extractor';
    priority = 95; // After module expansion, before execution order
    description = 'Extracts path requirements from modules for dynamic path generation';
    canTransform(genome) {
        return genome.modules && genome.modules.length > 0;
    }
    async transform(genome, context) {
        this.logStep(context, 'Extracting path requirements from modules', {
            modules: genome.modules.length
        });
        const domains = new Set();
        const domainModules = {};
        const requiredPaths = [];
        // Extract domains from all modules
        for (const module of genome.modules) {
            const domain = this.extractDomainFromModuleId(module.id);
            if (domain) {
                domains.add(domain);
                if (!domainModules[domain]) {
                    domainModules[domain] = [];
                }
                domainModules[domain].push(module.id);
            }
        }
        // Generate required paths for each domain
        const domainArray = Array.from(domains);
        for (const domain of domainArray) {
            // Standard domain paths (for adapters and features)
            requiredPaths.push(`packages.shared.src.${domain}.config`);
            requiredPaths.push(`packages.shared.src.${domain}.types`);
            requiredPaths.push(`packages.shared.src.${domain}.client`);
            // Check if domain has specific modules that need additional paths
            const modulesForDomain = domainModules[domain] || [];
            for (const moduleId of modulesForDomain) {
                const additionalPaths = this.getModuleSpecificPaths(moduleId, domain);
                requiredPaths.push(...additionalPaths);
            }
        }
        // Add path requirements to genome metadata
        const pathRequirements = {
            domains: domainArray,
            requiredPaths: Array.from(new Set(requiredPaths)), // Deduplicate
            domainModules
        };
        const updatedMetadata = {
            ...(genome.metadata || {}),
            pathRequirements
        };
        this.logSuccess(context, 'Path requirements extracted', {
            domains: domainArray.length,
            requiredPaths: requiredPaths.length
        });
        return {
            ...genome,
            metadata: updatedMetadata
        };
    }
    /**
     * Extract domain from module ID
     * Examples:
     * - 'adapters/payment/stripe' → 'payment'
     * - 'adapters/auth/better-auth' → 'auth'
     * - 'features/monitoring/shadcn' → 'monitoring'
     * - 'connectors/auth/better-auth-nextjs' → 'auth'
     */
    extractDomainFromModuleId(moduleId) {
        const parts = moduleId.split('/');
        // Infrastructure modules (not domains)
        const infrastructure = [
            'core', 'framework', 'monorepo', 'ui', 'database',
            'data-fetching', 'deployment', 'observability', 'services',
            'content', 'blockchain', 'testing', 'infrastructure', 'integrations',
            'analytics', 'email', 'jobs', 'storage', 'backend'
        ];
        let domain = null;
        // Pattern: adapters/{domain}/{provider}
        if (parts[0] === 'adapters' && parts.length >= 2) {
            domain = parts[1];
        }
        // Pattern: features/{domain}/{implementation}
        else if (parts[0] === 'features' && parts.length >= 2) {
            domain = parts[1];
        }
        // Pattern: connectors/{domain}/{provider-framework}
        else if (parts[0] === 'connectors' && parts.length >= 2) {
            domain = parts[1];
        }
        // Pattern: {domain}/{provider} (legacy)
        else if (parts.length >= 1) {
            domain = parts[0];
        }
        // Filter out infrastructure categories
        if (domain && infrastructure.includes(domain)) {
            return null;
        }
        // Normalize domain names
        if (domain) {
            // payment → payment, payments → payment
            if (domain === 'payments')
                return 'payment';
            if (domain === 'emailing')
                return 'email';
            if (domain === 'teams-management')
                return 'teams';
        }
        return domain || null;
    }
    /**
     * Get module-specific path requirements
     * Some modules need additional paths beyond the standard domain paths
     */
    getModuleSpecificPaths(moduleId, domain) {
        const paths = [];
        // Payment modules often need webhook paths
        if (domain === 'payment' && moduleId.includes('stripe')) {
            paths.push(`packages.shared.src.${domain}.webhooks`);
            paths.push(`apps.api.routes.${domain}.webhook`);
        }
        // Auth modules often need session paths
        if (domain === 'auth') {
            paths.push(`packages.shared.src.${domain}.session`);
            paths.push(`packages.shared.src.${domain}.middleware`);
        }
        // Monitoring modules often need config and utils
        if (domain === 'monitoring') {
            paths.push(`packages.shared.src.${domain}.utils`);
            paths.push(`packages.shared.src.${domain}.hooks`);
        }
        return paths;
    }
}
//# sourceMappingURL=path-requirements-extractor.js.map