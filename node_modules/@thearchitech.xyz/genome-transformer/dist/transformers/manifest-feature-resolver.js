import { BaseGenomeTransformer } from '../core/genome-transformer.js';
export class ManifestFeatureResolver extends BaseGenomeTransformer {
    name = 'Manifest Feature Resolver';
    priority = 2; // Early: resolve features to concrete modules before expansion/distribution
    description = 'Resolves abstract feature modules using manifests to concrete implementations';
    canTransform(genome) {
        return genome.modules.some(m => m.id?.startsWith('features/'));
    }
    async transform(genome, context) {
        this.logStep(context, 'Resolving feature modules via manifests', { modules: genome.modules.length });
        const resolved = [];
        for (const mod of genome.modules) {
            if (!mod.id?.startsWith('features/')) {
                resolved.push(mod);
                continue;
            }
            const needsManifest = await this.needsManifestResolution(mod.id, context.marketplacePath);
            if (!needsManifest) {
                resolved.push(mod);
                continue;
            }
            try {
                const featureId = this.extractFeatureId(mod.id);
                const manifest = await this.loadFeatureManifest(featureId, context.marketplacePath);
                const impls = this.pickImplementations(manifest, genome);
                for (const impl of impls) {
                    resolved.push({
                        id: impl.moduleId,
                        category: impl.type === 'backend' ? 'adapter' : 'feature',
                        parameters: { ...(impl.parameters || {}), ...(mod.parameters || {}) },
                    });
                }
            }
            catch (error) {
                context.logger.warn(`Manifest resolution failed for ${mod.id}, keeping as-is`, {
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                resolved.push(mod);
            }
        }
        this.logSuccess(context, 'Feature resolution complete', { modules: resolved.length });
        return { ...genome, modules: resolved };
    }
    async needsManifestResolution(moduleId, marketplacePath) {
        try {
            const { access } = await import('fs/promises');
            const { join } = await import('path');
            const featurePath = join(marketplacePath, moduleId);
            await access(join(featurePath, 'feature.json'));
            await access(join(featurePath, 'blueprint.ts'));
            return false; // direct feature exists
        }
        catch {
            return true;
        }
    }
    extractFeatureId(moduleId) {
        const withoutPrefix = moduleId.replace('features/', '');
        const parts = withoutPrefix.split('/');
        return parts[0] || withoutPrefix;
    }
    async loadFeatureManifest(featureId, marketplacePath) {
        const { readFile } = await import('fs/promises');
        const { join } = await import('path');
        const manifestPath = join(marketplacePath, 'dist', 'features', `${featureId}.manifest.json`);
        const content = await readFile(manifestPath, 'utf-8');
        return JSON.parse(content);
    }
    pickImplementations(manifest, genome) {
        if (!manifest.implementations || manifest.implementations.length === 0)
            return [];
        const apps = genome.project?.apps;
        const frameworks = apps?.map(a => a.framework) || [];
        const backendCandidates = manifest.implementations.filter(i => i.type === 'backend');
        const frontendCandidates = manifest.implementations.filter(i => i.type === 'frontend');
        const pickBest = (cands) => {
            if (cands.length === 0)
                return undefined;
            // Prefer impl whose stack intersects with selected frameworks
            let best;
            let bestScore = -1;
            for (const impl of cands) {
                const stack = (impl.stack || []).map(s => s.toLowerCase());
                const score = frameworks.reduce((acc, fw) => acc + (stack.includes(fw?.toLowerCase()) ? 1 : 0), 0);
                if (score > bestScore) {
                    bestScore = score;
                    best = impl;
                }
            }
            return best || cands[0];
        };
        const chosen = [];
        const b = pickBest(backendCandidates);
        const f = pickBest(frontendCandidates);
        if (b)
            chosen.push(b);
        if (f)
            chosen.push(f);
        return chosen;
    }
}
//# sourceMappingURL=manifest-feature-resolver.js.map